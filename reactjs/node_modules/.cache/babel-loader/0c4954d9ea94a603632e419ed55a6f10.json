{"ast":null,"code":"import { interceptConnections } from './intercept-connections';\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {\n  const nativeGainNode = nativeContext.createGain();\n  nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n  const disconnectGainNode = (disconnect => {\n    return () => {\n      // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n      disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n      nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n    };\n  })(nativeAudioScheduledSourceNode.disconnect);\n\n  nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n  interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n  nativeAudioScheduledSourceNode.stop = (stop => {\n    let isStopped = false;\n    return function () {\n      let when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (isStopped) {\n        try {\n          stop.call(nativeAudioScheduledSourceNode, when);\n        } catch {\n          nativeGainNode.gain.setValueAtTime(0, when);\n        }\n      } else {\n        stop.call(nativeAudioScheduledSourceNode, when);\n        isStopped = true;\n      }\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};","map":{"version":3,"mappings":"AACA,SAASA,oBAAT,QAAqC,yBAArC;AAEA,OAAO,MAAMC,sDAAsD,GAAoE,CACnIC,8BADmI,EAEnIC,aAFmI,KAGnI;EACA,MAAMC,cAAc,GAAGD,aAAa,CAACE,UAAd,EAAvB;EAEAH,8BAA8B,CAACI,OAA/B,CAAuCF,cAAvC;;EAEA,MAAMG,kBAAkB,GAAG,CAAEC,UAAD,IAAe;IACvC,OAAO,MAAK;MACR;MACyCA,UAAW,CAACC,IAAZ,CAAiBP,8BAAjB,EAAiDE,cAAjD;MACzCF,8BAA8B,CAACQ,mBAA/B,CAAmD,OAAnD,EAA4DH,kBAA5D;IACH,CAJD;EAKH,CAN0B,EAMxBL,8BAA8B,CAACM,UANP,CAA3B;;EAQAN,8BAA8B,CAACS,gBAA/B,CAAgD,OAAhD,EAAyDJ,kBAAzD;EAEAP,oBAAoB,CAACE,8BAAD,EAAiCE,cAAjC,CAApB;;EAEAF,8BAA8B,CAACU,IAA/B,GAAsC,CAAEA,IAAD,IAAS;IAC5C,IAAIC,SAAS,GAAG,KAAhB;IAEA,OAAO,YAAa;MAAA,IAAZC,IAAY,uEAAL,CAAK;;MAChB,IAAID,SAAJ,EAAe;QACX,IAAI;UACAD,IAAI,CAACH,IAAL,CAAUP,8BAAV,EAA0CY,IAA1C;QACH,CAFD,CAEE,MAAM;UACJV,cAAc,CAACW,IAAf,CAAoBC,cAApB,CAAmC,CAAnC,EAAsCF,IAAtC;QACH;MACJ,CAND,MAMO;QACHF,IAAI,CAACH,IAAL,CAAUP,8BAAV,EAA0CY,IAA1C;QAEAD,SAAS,GAAG,IAAZ;MACH;IACJ,CAZD;EAaH,CAhBqC,EAgBnCX,8BAA8B,CAACU,IAhBI,CAAtC;AAiBH,CArCM","names":["interceptConnections","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","nativeAudioScheduledSourceNode","nativeContext","nativeGainNode","createGain","connect","disconnectGainNode","disconnect","call","removeEventListener","addEventListener","stop","isStopped","when","gain","setValueAtTime"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\helpers\\wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts"],"sourcesContent":["import { TNativeAudioNode, TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction } from '../types';\nimport { interceptConnections } from './intercept-connections';\n\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls: TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction = (\n    nativeAudioScheduledSourceNode,\n    nativeContext\n) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            (<(destinaton: TNativeAudioNode) => void>disconnect).call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                } catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            } else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n"]},"metadata":{},"sourceType":"module"}