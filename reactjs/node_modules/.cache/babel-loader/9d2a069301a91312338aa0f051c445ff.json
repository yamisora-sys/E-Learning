{"ast":null,"code":"import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n  return class OfflineAudioContext extends baseAudioContextConstructor {\n    constructor(a, b, c) {\n      let options;\n\n      if (typeof a === 'number' && b !== undefined && c !== undefined) {\n        options = {\n          length: b,\n          numberOfChannels: a,\n          sampleRate: c\n        };\n      } else if (typeof a === 'object') {\n        options = a;\n      } else {\n        throw new Error('The given parameters are not valid.');\n      }\n\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n      const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n        nativeOfflineAudioContext.addEventListener('statechange', (() => {\n          let i = 0;\n\n          const delayStateChangeEvent = event => {\n            if (this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        })());\n      }\n\n      super(nativeOfflineAudioContext, numberOfChannels);\n      this._length = length;\n      this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      this._state = null;\n    }\n\n    get length() {\n      // Bug #17: Safari does not yet expose the length.\n      if (this._nativeOfflineAudioContext.length === undefined) {\n        return this._length;\n      }\n\n      return this._nativeOfflineAudioContext.length;\n    }\n\n    get state() {\n      return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n    }\n\n    startRendering() {\n      /*\n       * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n       * the state of the nativeOfflineAudioContext might no transition to running immediately.\n       */\n      if (this._state === 'running') {\n        return Promise.reject(createInvalidStateError());\n      }\n\n      this._state = 'running';\n      return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n        this._state = null;\n        deactivateAudioGraph(this);\n      });\n    }\n\n    _waitForThePromiseToSettle(event) {\n      if (this._state === null) {\n        this._nativeOfflineAudioContext.dispatchEvent(event);\n      } else {\n        setTimeout(() => this._waitForThePromiseToSettle(event));\n      }\n    }\n\n  };\n};","map":{"version":3,"mappings":"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","names":["deactivateAudioGraph","testPromiseSupport","DEFAULT_OPTIONS","numberOfChannels","createOfflineAudioContextConstructor","baseAudioContextConstructor","cacheTestResult","createInvalidStateError","createNativeOfflineAudioContext","startRendering","OfflineAudioContext","constructor","a","b","c","options","undefined","length","sampleRate","Error","nativeOfflineAudioContext","addEventListener","i","delayStateChangeEvent","event","_state","removeEventListener","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","state","Promise","reject","destination","finally","dispatchEvent","setTimeout"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\offline-audio-context-constructor.ts"],"sourcesContent":["import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TNativeOfflineAudioContext, TOfflineAudioContextConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createOfflineAudioContextConstructor: TOfflineAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor<IOfflineAudioContext> implements IOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions);\n        constructor(numberOfChannels: number, length: number, sampleRate: number);\n        constructor(a: number | IOfflineAudioContextOptions, b?: number, c?: number) {\n            let options: IOfflineAudioContextOptions;\n\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            } else if (typeof a === 'object') {\n                options = a;\n            } else {\n                throw new Error('The given parameters are not valid.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}