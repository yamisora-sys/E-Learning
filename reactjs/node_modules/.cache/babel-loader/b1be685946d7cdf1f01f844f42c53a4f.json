{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n    return function (set) {\n      var number = generateUniqueNumber(set);\n      set.add(number);\n      return number;\n    };\n  };\n\n  var createCache = function createCache(lastNumberWeakMap) {\n    return function (collection, nextNumber) {\n      lastNumberWeakMap.set(collection, nextNumber);\n      return nextNumber;\n    };\n  };\n  /*\n   * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n   * is fairly new.\n   */\n\n\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n  var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n  var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n\n  var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n    return function (collection) {\n      var lastNumber = lastNumberWeakMap.get(collection);\n      /*\n       * Let's try the cheapest algorithm first. It might fail to produce a new\n       * number, but it is so cheap that it is okay to take the risk. Just\n       * increase the last number by one or reset it to 0 if we reached the upper\n       * bound of SMIs (which stands for small integers). When the last number is\n       * unknown it is assumed that the collection contains zero based consecutive\n       * numbers.\n       */\n\n      var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n\n      if (!collection.has(nextNumber)) {\n        return cache(collection, nextNumber);\n      }\n      /*\n       * If there are less than half of 2 ** 30 numbers stored in the collection,\n       * the chance to generate a new random number in the range from 0 to 2 ** 30\n       * is at least 50%. It's benifitial to use only SMIs because they perform\n       * much better in any environment based on V8.\n       */\n\n\n      if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n        }\n\n        return cache(collection, nextNumber);\n      } // Quickly check if there is a theoretical chance to generate a new number.\n\n\n      if (collection.size > MAX_SAFE_INTEGER) {\n        throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n      } // Otherwise use the full scale of safely usable integers.\n\n\n      while (collection.has(nextNumber)) {\n        nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n      }\n\n      return cache(collection, nextNumber);\n    };\n  };\n\n  var LAST_NUMBER_WEAK_MAP = new WeakMap();\n  var cache = createCache(LAST_NUMBER_WEAK_MAP);\n  var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n  var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n  exports.addUniqueNumber = addUniqueNumber;\n  exports.generateUniqueNumber = generateUniqueNumber;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","fastUniqueNumbers","createAddUniqueNumber","generateUniqueNumber","set","number","add","createCache","lastNumberWeakMap","collection","nextNumber","MAX_SAFE_INTEGER","Number","undefined","TWO_TO_THE_POWER_OF_TWENTY_NINE","TWO_TO_THE_POWER_OF_THIRTY","createGenerateUniqueNumber","cache","lastNumber","get","size","has","Math","floor","random","Error","LAST_NUMBER_WEAK_MAP","WeakMap","addUniqueNumber","Object","defineProperty","value"],"sources":["D:/programer/xampp/htdocs/E-Learning/reactjs/node_modules/fast-unique-numbers/build/es5/bundle.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, (function (exports) { 'use strict';\n\n    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n      return function (set) {\n        var number = generateUniqueNumber(set);\n        set.add(number);\n        return number;\n      };\n    };\n\n    var createCache = function createCache(lastNumberWeakMap) {\n      return function (collection, nextNumber) {\n        lastNumberWeakMap.set(collection, nextNumber);\n        return nextNumber;\n      };\n    };\n\n    /*\n     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n     * is fairly new.\n     */\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n      return function (collection) {\n        var lastNumber = lastNumberWeakMap.get(collection);\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n\n        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n\n        if (!collection.has(nextNumber)) {\n          return cache(collection, nextNumber);\n        }\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n\n\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n          while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n          }\n\n          return cache(collection, nextNumber);\n        } // Quickly check if there is a theoretical chance to generate a new number.\n\n\n        if (collection.size > MAX_SAFE_INTEGER) {\n          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        } // Otherwise use the full scale of safely usable integers.\n\n\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n\n        return cache(collection, nextNumber);\n      };\n    };\n\n    var LAST_NUMBER_WEAK_MAP = new WeakMap();\n    var cache = createCache(LAST_NUMBER_WEAK_MAP);\n    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n\n    exports.addUniqueNumber = addUniqueNumber;\n    exports.generateUniqueNumber = generateUniqueNumber;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}