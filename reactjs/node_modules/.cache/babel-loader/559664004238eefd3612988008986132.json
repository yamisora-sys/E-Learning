{"ast":null,"code":"import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.'; // @todo This should live in a separate file.\n\nconst createPromisedAudioNodesEncoderIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\n  const {\n    encoderId,\n    port\n  } = await instantiate(mimeType, audioContext.sampleRate);\n\n  if (AudioWorkletNode === undefined) {\n    throw new Error(ERROR_MESSAGE);\n  }\n\n  const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, {\n    buffer: audioBuffer\n  });\n  const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, {\n    mediaStream\n  });\n  const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, {\n    channelCount\n  });\n  return {\n    audioBufferSourceNode,\n    encoderId,\n    mediaStreamAudioSourceNode,\n    port,\n    recorderAudioWorkletNode\n  };\n};\n\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\n  return (eventTarget, mediaStream, mimeType) => {\n    var _a;\n\n    const sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n    const audioContext = new MinimalAudioContext({\n      latencyHint: 'playback',\n      sampleRate\n    });\n    const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n    const audioBuffer = new AudioBuffer({\n      length,\n      sampleRate: audioContext.sampleRate\n    });\n    const bufferedArrayBuffers = [];\n    const promisedAudioWorkletModule = addRecorderAudioWorkletModule(url => {\n      if (addAudioWorkletModule === undefined) {\n        throw new Error(ERROR_MESSAGE);\n      }\n\n      return addAudioWorkletModule(audioContext, url);\n    });\n    let abortRecording = null;\n    let intervalId = null;\n    let promisedAudioNodesAndEncoderId = null;\n    let promisedPartialRecording = null;\n    let isAudioContextRunning = true;\n\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    const requestNextPartialRecording = async (encoderId, timeslice) => {\n      const arrayBuffers = await encode(encoderId, timeslice);\n\n      if (promisedAudioNodesAndEncoderId === null) {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n      }\n    };\n\n    const resume = () => {\n      isAudioContextRunning = true;\n      return audioContext.resume();\n    };\n\n    const stop = () => {\n      if (promisedAudioNodesAndEncoderId === null) {\n        return;\n      }\n\n      if (abortRecording !== null) {\n        mediaStream.removeEventListener('addtrack', abortRecording);\n        mediaStream.removeEventListener('removetrack', abortRecording);\n      }\n\n      if (intervalId !== null) {\n        clearTimeout(intervalId);\n      }\n\n      promisedAudioNodesAndEncoderId.then(async _ref => {\n        let {\n          encoderId,\n          mediaStreamAudioSourceNode,\n          recorderAudioWorkletNode\n        } = _ref;\n\n        if (promisedPartialRecording !== null) {\n          promisedPartialRecording.catch(() => {\n            /* @todo Only catch the errors caused by a duplicate call to encode. */\n          });\n          promisedPartialRecording = null;\n        }\n\n        await recorderAudioWorkletNode.stop();\n        mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n        const arrayBuffers = await encode(encoderId, null);\n\n        if (promisedAudioNodesAndEncoderId === null) {\n          await suspend();\n        }\n\n        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n        bufferedArrayBuffers.length = 0;\n        eventTarget.dispatchEvent(new Event('stop'));\n      });\n      promisedAudioNodesAndEncoderId = null;\n    };\n\n    const suspend = () => {\n      isAudioContextRunning = false;\n      return audioContext.suspend();\n    };\n\n    suspend();\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n      },\n\n      pause() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n\n        if (isAudioContextRunning) {\n          suspend();\n          eventTarget.dispatchEvent(new Event('pause'));\n        }\n      },\n\n      resume() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n\n        if (!isAudioContextRunning) {\n          resume();\n          eventTarget.dispatchEvent(new Event('resume'));\n        }\n      },\n\n      start(timeslice) {\n        var _a;\n\n        if (promisedAudioNodesAndEncoderId !== null) {\n          throw createInvalidStateError();\n        }\n\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        eventTarget.dispatchEvent(new Event('start'));\n        const audioTracks = mediaStream.getAudioTracks(); // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n        const channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n        promisedAudioNodesAndEncoderId = Promise.all([resume(), promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))]).then(async _ref2 => {\n          let [, {\n            audioBufferSourceNode,\n            encoderId,\n            mediaStreamAudioSourceNode,\n            port,\n            recorderAudioWorkletNode\n          }] = _ref2;\n          mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n          await new Promise(resolve => {\n            audioBufferSourceNode.onended = resolve;\n            audioBufferSourceNode.connect(recorderAudioWorkletNode);\n            audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n          });\n          audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n          await recorderAudioWorkletNode.record(port);\n\n          if (timeslice !== undefined) {\n            promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n          }\n\n          return {\n            encoderId,\n            mediaStreamAudioSourceNode,\n            recorderAudioWorkletNode\n          };\n        });\n        const tracks = mediaStream.getTracks();\n\n        abortRecording = () => {\n          stop();\n          eventTarget.dispatchEvent(new ErrorEvent('error', {\n            error: createInvalidModificationError()\n          }));\n        };\n\n        mediaStream.addEventListener('addtrack', abortRecording);\n        mediaStream.addEventListener('removetrack', abortRecording);\n        intervalId = setInterval(() => {\n          const currentTracks = mediaStream.getTracks();\n\n          if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) && abortRecording !== null) {\n            abortRecording();\n          }\n        }, 1000);\n      },\n\n      stop\n    };\n  };\n};","map":{"version":3,"mappings":"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","names":["encode","instantiate","addRecorderAudioWorkletModule","createRecorderAudioWorkletNode","AudioBuffer","AudioBufferSourceNode","AudioWorkletNode","MediaStreamAudioSourceNode","MinimalAudioContext","addAudioWorkletModule","ERROR_MESSAGE","createPromisedAudioNodesEncoderIdAndPort","audioBuffer","audioContext","channelCount","mediaStream","mimeType","encoderId","port","sampleRate","undefined","Error","audioBufferSourceNode","buffer","mediaStreamAudioSourceNode","recorderAudioWorkletNode","createWebAudioMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createInvalidStateError","createNotSupportedError","eventTarget","getAudioTracks","_a","getSettings","latencyHint","length","Math","max","ceil","baseLatency","bufferedArrayBuffers","promisedAudioWorkletModule","url","abortRecording","intervalId","promisedAudioNodesAndEncoderId","promisedPartialRecording","isAudioContextRunning","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","timeslice","push","resume","stop","removeEventListener","clearTimeout","then","catch","disconnect","suspend","Event","state","pause","start","getVideoTracks","audioTracks","Promise","all","connect","resolve","onended","currentTime","record","tracks","getTracks","ErrorEvent","error","addEventListener","setInterval","currentTracks","some","track","index"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\extendable-media-recorder\\src\\factories\\web-audio-media-recorder.ts"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport {\n    AudioBuffer,\n    AudioBufferSourceNode,\n    AudioWorkletNode,\n    IAudioBuffer,\n    IMinimalAudioContext,\n    MediaStreamAudioSourceNode,\n    MinimalAudioContext,\n    addAudioWorkletModule\n} from 'standardized-audio-context';\nimport { IAudioNodesAndEncoderId } from '../interfaces';\nimport { TRecordingState, TWebAudioMediaRecorderFactoryFactory } from '../types';\n\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (\n    audioBuffer: IAudioBuffer,\n    audioContext: IMinimalAudioContext,\n    channelCount: number,\n    mediaStream: MediaStream,\n    mimeType: string\n) => {\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\n\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\n\nexport const createWebAudioMediaRecorderFactory: TWebAudioMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createInvalidStateError,\n    createNotSupportedError\n) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        const sampleRate = mediaStream.getAudioTracks()[0]?.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url: string) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n\n            return addAudioWorkletModule(audioContext, url);\n        });\n\n        let abortRecording: null | (() => void) = null;\n        let intervalId: null | number = null;\n        let promisedAudioNodesAndEncoderId: null | Promise<IAudioNodesAndEncoderId> = null;\n        let promisedPartialRecording: null | Promise<void> = null;\n        let isAudioContextRunning = true;\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (promisedAudioNodesAndEncoderId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const resume = (): Promise<void> => {\n            isAudioContextRunning = true;\n\n            return audioContext.resume();\n        };\n\n        const stop = (): void => {\n            if (promisedAudioNodesAndEncoderId === null) {\n                return;\n            }\n\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n\n            promisedAudioNodesAndEncoderId.then(async ({ encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                if (promisedPartialRecording !== null) {\n                    promisedPartialRecording.catch(() => {\n                        /* @todo Only catch the errors caused by a duplicate call to encode. */\n                    });\n                    promisedPartialRecording = null;\n                }\n\n                await recorderAudioWorkletNode.stop();\n\n                mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n\n                const arrayBuffers = await encode(encoderId, null);\n\n                if (promisedAudioNodesAndEncoderId === null) {\n                    await suspend();\n                }\n\n                dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                bufferedArrayBuffers.length = 0;\n\n                eventTarget.dispatchEvent(new Event('stop'));\n            });\n\n            promisedAudioNodesAndEncoderId = null;\n        };\n\n        const suspend = (): Promise<void> => {\n            isAudioContextRunning = false;\n\n            return audioContext.suspend();\n        };\n\n        suspend();\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n\n            pause(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n\n            resume(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n\n            start(timeslice?: number): void {\n                if (promisedAudioNodesAndEncoderId !== null) {\n                    throw createInvalidStateError();\n                }\n\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                eventTarget.dispatchEvent(new Event('start'));\n\n                const audioTracks = mediaStream.getAudioTracks();\n                // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n                const channelCount =\n                    audioTracks.length === 0\n                        ? 2\n                        : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount ?? 2;\n\n                promisedAudioNodesAndEncoderId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() =>\n                        createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType)\n                    )\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n\n                    await recorderAudioWorkletNode.record(port);\n\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                    return { encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n\n                const tracks = mediaStream.getTracks();\n\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n\n                    if (\n                        (currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null\n                    ) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n\n            stop\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}