{"ast":null,"code":"export const createRenderInputsOfAudioNode = (getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle) => {\n  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).map(async _ref => {\n      let [source, output] = _ref;\n      const audioNodeRenderer = getAudioNodeRenderer(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n      const destination = audioNode.context.destination;\n\n      if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n        renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n      }\n    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n  };\n};","map":{"version":3,"mappings":"AAGA,OAAO,MAAMA,6BAA6B,GAAoC,CAC1EC,uBAD0E,EAE1EC,oBAF0E,EAG1EC,cAH0E,KAI1E;EACA,OAAO,OAAOC,SAAP,EAAkBC,yBAAlB,EAA6CC,eAA7C,KAAgE;IACnE,MAAMC,oBAAoB,GAAGN,uBAAuB,CAACG,SAAD,CAApD;IAEA,MAAMI,OAAO,CAACC,GAAR,CACFF,oBAAoB,CAACG,YAArB,CACKC,GADL,CACS,CAACC,WAAD,EAAcC,KAAd,KACDC,KAAK,CAACC,IAAN,CAAWH,WAAX,EAAwBD,GAAxB,CAA4B,cAA2B;MAAA,IAApB,CAACK,MAAD,EAASC,MAAT,CAAoB;MACnD,MAAMC,iBAAiB,GAAGhB,oBAAoB,CAACc,MAAD,CAA9C;MACA,MAAMG,uBAAuB,GAAG,MAAMD,iBAAiB,CAACE,MAAlB,CAAyBJ,MAAzB,EAAiCX,yBAAjC,CAAtC;MACA,MAAMgB,WAAW,GAAoDjB,SAAS,CAACkB,OAAV,CAAkBD,WAAvF;;MAEA,IAAI,CAAClB,cAAc,CAACa,MAAD,CAAf,KAA4BZ,SAAS,KAAKiB,WAAd,IAA6B,CAAClB,cAAc,CAACC,SAAD,CAAxE,CAAJ,EAA0F;QACtFe,uBAAuB,CAACI,OAAxB,CAAgCjB,eAAhC,EAAiDW,MAAjD,EAAyDJ,KAAzD;MACH;IACJ,CARD,CAFR,EAYKW,MAZL,CAYY,CAACC,oBAAD,EAAuBC,iBAAvB,KAA6C,CAAC,GAAGD,oBAAJ,EAA0B,GAAGC,iBAA7B,CAZzD,EAY0G,EAZ1G,CADE,CAAN;EAeH,CAlBD;AAmBH,CAxBM","names":["createRenderInputsOfAudioNode","getAudioNodeConnections","getAudioNodeRenderer","isPartOfACycle","audioNode","nativeOfflineAudioContext","nativeAudioNode","audioNodeConnections","Promise","all","activeInputs","map","connections","input","Array","from","source","output","audioNodeRenderer","renderedNativeAudioNode","render","destination","context","connect","reduce","allRenderingPromises","renderingPromises"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\render-inputs-of-audio-node.ts"],"sourcesContent":["import { IAudioDestinationNode } from '../interfaces';\nimport { TRenderInputsOfAudioNodeFactory } from '../types';\n\nexport const createRenderInputsOfAudioNode: TRenderInputsOfAudioNodeFactory = (\n    getAudioNodeConnections,\n    getAudioNodeRenderer,\n    isPartOfACycle\n) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        await Promise.all(\n            audioNodeConnections.activeInputs\n                .map((connections, input) =>\n                    Array.from(connections).map(async ([source, output]) => {\n                        const audioNodeRenderer = getAudioNodeRenderer(source);\n                        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        const destination = <IAudioDestinationNode<typeof audioNode.context>>audioNode.context.destination;\n\n                        if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                            renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                        }\n                    })\n                )\n                .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], [])\n        );\n    };\n};\n"]},"metadata":{},"sourceType":"module"}