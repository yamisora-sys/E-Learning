{"ast":null,"code":"import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) => {\n  return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n    const audioTracks = mediaStream.getAudioTracks();\n    const bufferedArrayBuffers = []; // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n    const channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n    let promisedPartialRecording = null;\n\n    let stopRecording = () => {}; // tslint:disable-line:no-empty\n\n\n    const dispatchDataAvailableEvent = arrayBuffers => {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    const requestNextPartialRecording = async (encoderId, timeslice) => {\n      const arrayBuffers = await encode(encoderId, timeslice);\n\n      if (nativeMediaRecorder.state === 'inactive') {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n      }\n    };\n\n    const stop = () => {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(() => {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n\n      stopRecording();\n\n      stopRecording = () => {}; // tslint:disable-line:no-empty\n\n\n      nativeMediaRecorder.stop();\n    };\n\n    nativeMediaRecorder.addEventListener('error', () => {\n      stop(); // Bug #3 & #4: Chrome throws an error event without any error.\n\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: createInvalidModificationError()\n      }));\n    });\n    nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n\n      pause() {\n        return nativeMediaRecorder.pause();\n      },\n\n      resume() {\n        return nativeMediaRecorder.resume();\n      },\n\n      start(timeslice) {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        if (nativeMediaRecorder.state === 'inactive') {\n          if (sampleRate === undefined) {\n            throw new Error('The sampleRate is not defined.');\n          }\n\n          let isRecording = false;\n          let isStopped = false; // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n\n          let pendingInvocations = 0;\n          let promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n\n          stopRecording = () => {\n            isStopped = true;\n          };\n\n          const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(_ref => {\n            let {\n              data\n            } = _ref;\n            pendingInvocations += 1;\n            promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(async _ref2 => {\n              let {\n                dataView = null,\n                elementType = null,\n                encoderId,\n                port\n              } = _ref2;\n              const arrayBuffer = await data.arrayBuffer();\n              pendingInvocations -= 1;\n              const currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n\n              if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                if (lengthAndValue === null) {\n                  return {\n                    dataView: currentDataView,\n                    elementType,\n                    encoderId,\n                    port\n                  };\n                }\n\n                const {\n                  value\n                } = lengthAndValue;\n\n                if (value !== 172351395) {\n                  return {\n                    dataView,\n                    elementType,\n                    encoderId,\n                    port\n                  };\n                }\n\n                isRecording = true;\n              }\n\n              const {\n                currentElementType,\n                offset,\n                contents\n              } = decodeWebMChunk(currentDataView, elementType, channelCount);\n              const remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n              contents.forEach(content => port.postMessage(content, content.map(_ref3 => {\n                let {\n                  buffer\n                } = _ref3;\n                return buffer;\n              })));\n\n              if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                encode(encoderId, null).then(arrayBuffers => {\n                  dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                  bufferedArrayBuffers.length = 0;\n                  eventTarget.dispatchEvent(new Event('stop'));\n                });\n                port.postMessage([]);\n                port.close();\n                removeEventListener();\n              }\n\n              return {\n                dataView: remainingDataView,\n                elementType: currentElementType,\n                encoderId,\n                port\n              };\n            });\n          });\n\n          if (timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(_ref4 => {\n              let {\n                encoderId\n              } = _ref4;\n              return promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            });\n          }\n        }\n\n        nativeMediaRecorder.start(100);\n      },\n\n      stop\n    };\n  };\n};","map":{"version":3,"mappings":"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","names":["encode","instantiate","MultiBufferDataView","on","createWebmPcmMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createNotSupportedError","decodeWebMChunk","readVariableSizeInteger","eventTarget","nativeMediaRecorderConstructor","mediaStream","mimeType","audioTracks","getAudioTracks","bufferedArrayBuffers","channelCount","length","undefined","getSettings","nativeMediaRecorder","sampleRate","promisedPartialRecording","stopRecording","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","encoderId","timeslice","state","push","stop","catch","addEventListener","ErrorEvent","error","Event","pause","resume","start","getVideoTracks","Error","isRecording","isStopped","pendingInvocations","promisedDataViewElementTypeEncoderIdAndPort","removeEventListener","then","dataView","elementType","port","arrayBuffer","currentDataView","buffers","byteOffset","lengthAndValue","value","currentElementType","offset","contents","remainingDataView","byteLength","forEach","content","postMessage","map","buffer","close"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\extendable-media-recorder\\src\\factories\\webm-pcm-media-recorder.ts"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nimport { TPromisedDataViewElementTypeEncoderIdAndPort, TRecordingState, TWebmPcmMediaRecorderFactoryFactory } from '../types';\n\nexport const createWebmPcmMediaRecorderFactory: TWebmPcmMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createNotSupportedError,\n    decodeWebMChunk,\n    readVariableSizeInteger\n) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const audioTracks = mediaStream.getAudioTracks();\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n        const channelCount =\n            audioTracks.length === 0\n                ? undefined\n                : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount;\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n        const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n\n        let promisedPartialRecording: null | Promise<void> = null;\n        let stopRecording = () => {}; // tslint:disable-line:no-empty\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const stop = (): void => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n\n            stopRecording();\n            stopRecording = () => {}; // tslint:disable-line:no-empty\n\n            nativeMediaRecorder.stop();\n        };\n\n        nativeMediaRecorder.addEventListener('error', () => {\n            stop();\n            // Bug #3 & #4: Chrome throws an error event without any error.\n            eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n        });\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return nativeMediaRecorder.state;\n            },\n\n            pause(): void {\n                return nativeMediaRecorder.pause();\n            },\n\n            resume(): void {\n                return nativeMediaRecorder.resume();\n            },\n\n            start(timeslice?: number): void {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderIdAndPort: TPromisedDataViewElementTypeEncoderIdAndPort = instantiate(\n                        mimeType,\n                        sampleRate\n                    );\n\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n\n                    const removeEventListener = on(\n                        nativeMediaRecorder,\n                        'dataavailable'\n                    )(({ data }) => {\n                        pendingInvocations += 1;\n\n                        promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(\n                            async ({ dataView = null, elementType = null, encoderId, port }) => {\n                                const arrayBuffer = await data.arrayBuffer();\n\n                                pendingInvocations -= 1;\n\n                                const currentDataView =\n                                    dataView === null\n                                        ? new MultiBufferDataView([arrayBuffer])\n                                        : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n\n                                if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                    const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                                    if (lengthAndValue === null) {\n                                        return { dataView: currentDataView, elementType, encoderId, port };\n                                    }\n\n                                    const { value } = lengthAndValue;\n\n                                    if (value !== 172351395) {\n                                        return { dataView, elementType, encoderId, port };\n                                    }\n\n                                    isRecording = true;\n                                }\n\n                                const { currentElementType, offset, contents } = decodeWebMChunk(\n                                    currentDataView,\n                                    elementType,\n                                    channelCount\n                                );\n                                const remainingDataView =\n                                    offset < currentDataView.byteLength\n                                        ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                        : null;\n\n                                contents.forEach((content) =>\n                                    port.postMessage(\n                                        content,\n                                        content.map(({ buffer }) => buffer)\n                                    )\n                                );\n\n                                if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                    encode(encoderId, null).then((arrayBuffers) => {\n                                        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                                        bufferedArrayBuffers.length = 0;\n\n                                        eventTarget.dispatchEvent(new Event('stop'));\n                                    });\n\n                                    port.postMessage([]);\n                                    port.close();\n\n                                    removeEventListener();\n                                }\n\n                                return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\n                            }\n                        );\n                    });\n\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderIdAndPort.then(\n                            ({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice))\n                        );\n                    }\n                }\n\n                nativeMediaRecorder.start(100);\n            },\n\n            stop\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}