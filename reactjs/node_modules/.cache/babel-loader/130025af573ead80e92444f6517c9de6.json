{"ast":null,"code":"export const createNativeMediaRecorderFactory = (createInvalidModificationError, createNotSupportedError) => {\n  return (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n    const bufferedBlobs = [];\n    const dataAvailableListeners = new WeakMap();\n    const errorListeners = new WeakMap();\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n    const stopListeners = new WeakMap();\n    let isActive = true;\n\n    nativeMediaRecorder.addEventListener = (addEventListener => {\n      return (type, listener, options) => {\n        let patchedEventListener = listener;\n\n        if (typeof listener === 'function') {\n          if (type === 'dataavailable') {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            patchedEventListener = event => {\n              setTimeout(() => {\n                if (isActive && nativeMediaRecorder.state === 'inactive') {\n                  bufferedBlobs.push(event.data);\n                } else {\n                  if (bufferedBlobs.length > 0) {\n                    const blob = event.data;\n                    Object.defineProperty(event, 'data', {\n                      value: new Blob([...bufferedBlobs, blob], {\n                        type: blob.type\n                      })\n                    });\n                    bufferedBlobs.length = 0;\n                  }\n\n                  listener.call(nativeMediaRecorder, event);\n                }\n              });\n            };\n\n            dataAvailableListeners.set(listener, patchedEventListener);\n          } else if (type === 'error') {\n            // Bug #12 & #13: Firefox fires a regular event with an error property.\n            patchedEventListener = event => {\n              // Bug #3 & #4: Chrome throws an error event without any error.\n              if (event.error === undefined) {\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: createInvalidModificationError()\n                })); // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n              } else if (event.error.name === 'UnknownError') {\n                const message = event.error.message;\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: createInvalidModificationError(message)\n                }));\n              } else if (event instanceof ErrorEvent) {\n                listener.call(nativeMediaRecorder, event);\n              } else {\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: event.error\n                }));\n              }\n            };\n\n            errorListeners.set(listener, patchedEventListener);\n          } else if (type === 'stop') {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            patchedEventListener = event => {\n              isActive = false;\n              setTimeout(() => listener.call(nativeMediaRecorder, event));\n            };\n\n            stopListeners.set(listener, patchedEventListener);\n          }\n        }\n\n        return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n      };\n    })(nativeMediaRecorder.addEventListener);\n\n    nativeMediaRecorder.dispatchEvent = (dispatchEvent => {\n      // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n      return event => {\n        let wasActive;\n        setTimeout(() => {\n          wasActive = isActive;\n          isActive = false;\n        });\n        const returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n        setTimeout(() => isActive = wasActive);\n        return returnValue;\n      };\n    })(nativeMediaRecorder.dispatchEvent);\n\n    nativeMediaRecorder.removeEventListener = (removeEventListener => {\n      return (type, listener, options) => {\n        let patchedEventListener = listener;\n\n        if (typeof listener === 'function') {\n          if (type === 'dataavailable') {\n            const dataAvailableListener = dataAvailableListeners.get(listener);\n\n            if (dataAvailableListener !== undefined) {\n              patchedEventListener = dataAvailableListener;\n            }\n          } else if (type === 'error') {\n            const errorListener = errorListeners.get(listener);\n\n            if (errorListener !== undefined) {\n              patchedEventListener = errorListener;\n            }\n          } else if (type === 'stop') {\n            const stopListener = stopListeners.get(listener);\n\n            if (stopListener !== undefined) {\n              patchedEventListener = stopListener;\n            }\n          }\n        }\n\n        return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n      };\n    })(nativeMediaRecorder.removeEventListener);\n\n    nativeMediaRecorder.start = (start => {\n      return timeslice => {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaRecorderOptions.mimeType !== undefined && mediaRecorderOptions.mimeType.startsWith('audio/') && stream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        isActive = timeslice !== undefined;\n        return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n      };\n    })(nativeMediaRecorder.start);\n\n    return nativeMediaRecorder;\n  };\n};","map":{"version":3,"mappings":"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","names":["createNativeMediaRecorderFactory","createInvalidModificationError","createNotSupportedError","nativeMediaRecorderConstructor","stream","mediaRecorderOptions","bufferedBlobs","dataAvailableListeners","WeakMap","errorListeners","nativeMediaRecorder","stopListeners","isActive","addEventListener","type","listener","options","patchedEventListener","event","setTimeout","state","push","data","length","blob","Object","defineProperty","value","Blob","call","set","error","undefined","ErrorEvent","name","message","dispatchEvent","wasActive","returnValue","removeEventListener","dataAvailableListener","get","errorListener","stopListener","start","timeslice","mimeType","startsWith","getVideoTracks"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\extendable-media-recorder\\src\\factories\\native-media-recorder.ts"],"sourcesContent":["import { IBlobEvent, IMediaRecorder } from '../interfaces';\nimport { TEventHandler, TNativeMediaRecorderFactoryFactory } from '../types';\n\nexport const createNativeMediaRecorderFactory: TNativeMediaRecorderFactoryFactory = (\n    createInvalidModificationError,\n    createNotSupportedError\n) => {\n    return (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) => {\n        const bufferedBlobs: Blob[] = [];\n        const dataAvailableListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: IBlobEvent) => void>();\n        const errorListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: ErrorEvent) => void>();\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n        const stopListeners = new WeakMap<EventListener, (this: IMediaRecorder, event: Event) => void>();\n\n        let isActive = true;\n\n        nativeMediaRecorder.addEventListener = ((addEventListener) => {\n            return (\n                type: string,\n                listener: null | TEventHandler<IMediaRecorder> | EventListenerOrEventListenerObject,\n                options?: boolean | AddEventListenerOptions\n            ) => {\n                let patchedEventListener = listener;\n\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                        patchedEventListener = (event: IBlobEvent) => {\n                            setTimeout(() => {\n                                if (isActive && nativeMediaRecorder.state === 'inactive') {\n                                    bufferedBlobs.push(event.data);\n                                } else {\n                                    if (bufferedBlobs.length > 0) {\n                                        const blob = event.data;\n\n                                        Object.defineProperty(event, 'data', {\n                                            value: new Blob([...bufferedBlobs, blob], { type: blob.type })\n                                        });\n\n                                        bufferedBlobs.length = 0;\n                                    }\n\n                                    listener.call(nativeMediaRecorder, event);\n                                }\n                            });\n                        };\n\n                        dataAvailableListeners.set(listener, patchedEventListener);\n                    } else if (type === 'error') {\n                        // Bug #12 & #13: Firefox fires a regular event with an error property.\n                        patchedEventListener = (event: ErrorEvent | (Event & { error?: Error })) => {\n                            // Bug #3 & #4: Chrome throws an error event without any error.\n                            if (event.error === undefined) {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: createInvalidModificationError() }));\n                                // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n                            } else if (event.error.name === 'UnknownError') {\n                                const message = event.error.message;\n\n                                listener.call(\n                                    nativeMediaRecorder,\n                                    new ErrorEvent('error', { error: createInvalidModificationError(message) })\n                                );\n                            } else if (event instanceof ErrorEvent) {\n                                listener.call(nativeMediaRecorder, event);\n                            } else {\n                                listener.call(nativeMediaRecorder, new ErrorEvent('error', { error: event.error }));\n                            }\n                        };\n\n                        errorListeners.set(listener, patchedEventListener);\n                    } else if (type === 'stop') {\n                        // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n                        patchedEventListener = (event: Event) => {\n                            isActive = false;\n\n                            setTimeout(() => listener.call(nativeMediaRecorder, event));\n                        };\n\n                        stopListeners.set(listener, patchedEventListener);\n                    }\n                }\n\n                return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.addEventListener);\n\n        nativeMediaRecorder.dispatchEvent = ((dispatchEvent) => {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            return (event: Event) => {\n                let wasActive: boolean;\n\n                setTimeout(() => {\n                    wasActive = isActive;\n                    isActive = false;\n                });\n\n                const returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n\n                setTimeout(() => (isActive = wasActive));\n\n                return returnValue;\n            };\n        })(nativeMediaRecorder.dispatchEvent);\n\n        nativeMediaRecorder.removeEventListener = ((removeEventListener) => {\n            return (\n                type: string,\n                listener: null | TEventHandler<IMediaRecorder> | EventListenerOrEventListenerObject,\n                options?: boolean | EventListenerOptions\n            ) => {\n                let patchedEventListener = listener;\n\n                if (typeof listener === 'function') {\n                    if (type === 'dataavailable') {\n                        const dataAvailableListener = dataAvailableListeners.get(listener);\n\n                        if (dataAvailableListener !== undefined) {\n                            patchedEventListener = dataAvailableListener;\n                        }\n                    } else if (type === 'error') {\n                        const errorListener = errorListeners.get(listener);\n\n                        if (errorListener !== undefined) {\n                            patchedEventListener = errorListener;\n                        }\n                    } else if (type === 'stop') {\n                        const stopListener = stopListeners.get(listener);\n\n                        if (stopListener !== undefined) {\n                            patchedEventListener = stopListener;\n                        }\n                    }\n                }\n\n                return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n            };\n        })(nativeMediaRecorder.removeEventListener);\n\n        nativeMediaRecorder.start = ((start) => {\n            return (timeslice?: number) => {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (\n                    mediaRecorderOptions.mimeType !== undefined &&\n                    mediaRecorderOptions.mimeType.startsWith('audio/') &&\n                    stream.getVideoTracks().length > 0\n                ) {\n                    throw createNotSupportedError();\n                }\n\n                isActive = timeslice !== undefined;\n\n                return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n            };\n        })(nativeMediaRecorder.start);\n\n        return nativeMediaRecorder;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}