{"ast":null,"code":"import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors) => {\n  return (nativeContext, options) => {\n    const nativeWaveShaperNode = nativeContext.createWaveShaper();\n    /*\n     * Bug #119: Safari does not correctly map the values.\n     * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n     * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n     * isn't necessary anymore since v14.0.2 of Safari.\n     */\n\n    if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext' && nativeContext.createGain().gain.automationRate === undefined) {\n      return createNativeWaveShaperNodeFaker(nativeContext, options);\n    }\n\n    assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n    const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve); // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n\n    if (curve !== null && curve.length < 2) {\n      throw createInvalidStateError();\n    } // Only values of type Float32Array can be assigned to the curve property.\n\n\n    assignNativeAudioNodeOption(nativeWaveShaperNode, {\n      curve\n    }, 'curve');\n    assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n    let disconnectNativeAudioBufferSourceNode = null;\n    let isConnected = false;\n    overwriteAccessors(nativeWaveShaperNode, 'curve', get => () => get.call(nativeWaveShaperNode), set => value => {\n      set.call(nativeWaveShaperNode, value);\n\n      if (isConnected) {\n        if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n          disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n        } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n          disconnectNativeAudioBufferSourceNode();\n          disconnectNativeAudioBufferSourceNode = null;\n        }\n      }\n\n      return value;\n    });\n\n    const whenConnected = () => {\n      isConnected = true;\n\n      if (isDCCurve(nativeWaveShaperNode.curve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n      }\n    };\n\n    const whenDisconnected = () => {\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"mappings":"AAAA,SAASA,2BAAT,QAA4C,4CAA5C;AACA,SAASC,4BAAT,QAA6C,6CAA7C;AAGA,OAAO,MAAMC,iCAAiC,GAAwC,CAClFC,0CADkF,EAElFC,uBAFkF,EAGlFC,+BAHkF,EAIlFC,SAJkF,EAKlFC,kBALkF,EAMlFC,6BANkF,EAOlFC,kBAPkF,KAQlF;EACA,OAAO,CAACC,aAAD,EAAgBC,OAAhB,KAA2B;IAC9B,MAAMC,oBAAoB,GAAGF,aAAa,CAACG,gBAAd,EAA7B;IAEA;;;;;;;IAMA,IACIL,6BAA6B,KAAK,IAAlC,IACAA,6BAA6B,CAACM,IAA9B,KAAuC,oBADvC,IAEAJ,aAAa,CAACK,UAAd,GAA2BC,IAA3B,CAAgCC,cAAhC,KAAmDC,SAHvD,EAIE;MACE,OAAOb,+BAA+B,CAACK,aAAD,EAAgBC,OAAhB,CAAtC;IACH;;IAEDV,4BAA4B,CAACW,oBAAD,EAAuBD,OAAvB,CAA5B;IAEA,MAAMQ,KAAK,GAAGR,OAAO,CAACQ,KAAR,KAAkB,IAAlB,IAA0BR,OAAO,CAACQ,KAAR,YAAyBC,YAAnD,GAAkET,OAAO,CAACQ,KAA1E,GAAkF,IAAIC,YAAJ,CAAiBT,OAAO,CAACQ,KAAzB,CAAhG,CAnB8B,CAqB9B;;IACA,IAAIA,KAAK,KAAK,IAAV,IAAkBA,KAAK,CAACE,MAAN,GAAe,CAArC,EAAwC;MACpC,MAAMjB,uBAAuB,EAA7B;IACH,CAxB6B,CA0B9B;;;IACAJ,2BAA2B,CAACY,oBAAD,EAAuB;MAAEO;IAAF,CAAvB,EAAkC,OAAlC,CAA3B;IACAnB,2BAA2B,CAACY,oBAAD,EAAuBD,OAAvB,EAAgC,YAAhC,CAA3B;IAEA,IAAIW,qCAAqC,GAAwB,IAAjE;IACA,IAAIC,WAAW,GAAG,KAAlB;IAEAd,kBAAkB,CACdG,oBADc,EAEd,OAFc,EAGbY,GAAD,IAAS,MAAMA,GAAG,CAACC,IAAJ,CAASb,oBAAT,CAHD,EAIbc,GAAD,IAAUC,KAAD,IAAU;MACfD,GAAG,CAACD,IAAJ,CAASb,oBAAT,EAA+Be,KAA/B;;MAEA,IAAIJ,WAAJ,EAAiB;QACb,IAAIjB,SAAS,CAACqB,KAAD,CAAT,IAAoBL,qCAAqC,KAAK,IAAlE,EAAwE;UACpEA,qCAAqC,GAAGnB,0CAA0C,CAC9EO,aAD8E,EAE9EE,oBAF8E,CAAlF;QAIH,CALD,MAKO,IAAI,CAACN,SAAS,CAACqB,KAAD,CAAV,IAAqBL,qCAAqC,KAAK,IAAnE,EAAyE;UAC5EA,qCAAqC;UACrCA,qCAAqC,GAAG,IAAxC;QACH;MACJ;;MAED,OAAOK,KAAP;IACH,CApBa,CAAlB;;IAuBA,MAAMC,aAAa,GAAG,MAAK;MACvBL,WAAW,GAAG,IAAd;;MAEA,IAAIjB,SAAS,CAACM,oBAAoB,CAACO,KAAtB,CAAb,EAA2C;QACvCG,qCAAqC,GAAGnB,0CAA0C,CAACO,aAAD,EAAgBE,oBAAhB,CAAlF;MACH;IACJ,CAND;;IAOA,MAAMiB,gBAAgB,GAAG,MAAK;MAC1BN,WAAW,GAAG,KAAd;;MAEA,IAAID,qCAAqC,KAAK,IAA9C,EAAoD;QAChDA,qCAAqC;QACrCA,qCAAqC,GAAG,IAAxC;MACH;IACJ,CAPD;;IASA,OAAOf,kBAAkB,CAACK,oBAAD,EAAuBgB,aAAvB,EAAsCC,gBAAtC,CAAzB;EACH,CAzED;AA0EH,CAnFM","names":["assignNativeAudioNodeOption","assignNativeAudioNodeOptions","createNativeWaveShaperNodeFactory","createConnectedNativeAudioBufferSourceNode","createInvalidStateError","createNativeWaveShaperNodeFaker","isDCCurve","monitorConnections","nativeAudioContextConstructor","overwriteAccessors","nativeContext","options","nativeWaveShaperNode","createWaveShaper","name","createGain","gain","automationRate","undefined","curve","Float32Array","length","disconnectNativeAudioBufferSourceNode","isConnected","get","call","set","value","whenConnected","whenDisconnected"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\native-wave-shaper-node-factory.ts"],"sourcesContent":["import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeWaveShaperNodeFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFactory: TNativeWaveShaperNodeFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (\n            nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined\n        ) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n\n        overwriteAccessors(\n            nativeWaveShaperNode,\n            'curve',\n            (get) => () => get.call(nativeWaveShaperNode),\n            (set) => (value) => {\n                set.call(nativeWaveShaperNode, value);\n\n                if (isConnected) {\n                    if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(\n                            nativeContext,\n                            nativeWaveShaperNode\n                        );\n                    } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n\n                return value;\n            }\n        );\n\n        const whenConnected = () => {\n            isConnected = true;\n\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n"]},"metadata":{},"sourceType":"module"}