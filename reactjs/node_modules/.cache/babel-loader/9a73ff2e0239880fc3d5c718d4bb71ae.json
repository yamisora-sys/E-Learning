{"ast":null,"code":"import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = nativeAudioNode => {\n  const connections = new Map();\n\n  nativeAudioNode.connect = (connect => {\n    // tslint:disable-next-line:invalid-void no-inferrable-types\n    return function (destination) {\n      let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output); // Save the new connection only if the calls to connect above didn't throw an error.\n\n      const connectionsToDestination = connections.get(destination);\n\n      if (connectionsToDestination === undefined) {\n        connections.set(destination, [{\n          input,\n          output\n        }]);\n      } else {\n        if (connectionsToDestination.every(connection => connection.input !== input || connection.output !== output)) {\n          connectionsToDestination.push({\n            input,\n            output\n          });\n        }\n      }\n\n      return returnValue;\n    };\n  })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n  nativeAudioNode.disconnect = (disconnect => {\n    return (destinationOrOutput, output, input) => {\n      disconnect.apply(nativeAudioNode);\n\n      if (destinationOrOutput === undefined) {\n        connections.clear();\n      } else if (typeof destinationOrOutput === 'number') {\n        for (const [destination, connectionsToDestination] of connections) {\n          const filteredConnections = connectionsToDestination.filter(connection => connection.output !== destinationOrOutput);\n\n          if (filteredConnections.length === 0) {\n            connections.delete(destination);\n          } else {\n            connections.set(destination, filteredConnections);\n          }\n        }\n      } else if (connections.has(destinationOrOutput)) {\n        if (output === undefined) {\n          connections.delete(destinationOrOutput);\n        } else {\n          const connectionsToDestination = connections.get(destinationOrOutput);\n\n          if (connectionsToDestination !== undefined) {\n            const filteredConnections = connectionsToDestination.filter(connection => connection.output !== output && (connection.input !== input || input === undefined));\n\n            if (filteredConnections.length === 0) {\n              connections.delete(destinationOrOutput);\n            } else {\n              connections.set(destinationOrOutput, filteredConnections);\n            }\n          }\n        }\n      }\n\n      for (const [destination, connectionsToDestination] of connections) {\n        connectionsToDestination.forEach(connection => {\n          if (isNativeAudioNode(destination)) {\n            nativeAudioNode.connect(destination, connection.output, connection.input);\n          } else {\n            nativeAudioNode.connect(destination, connection.output);\n          }\n        });\n      }\n    };\n  })(nativeAudioNode.disconnect);\n};","map":{"version":3,"mappings":"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","names":["isNativeAudioNode","wrapAudioNodeDisconnectMethod","nativeAudioNode","connections","Map","connect","destination","output","input","returnValue","connectionsToDestination","get","undefined","set","every","connection","push","bind","disconnect","destinationOrOutput","apply","clear","filteredConnections","filter","length","delete","has","forEach"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\helpers\\wrap-audio-node-disconnect-method.ts"],"sourcesContent":["import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode: TNativeAudioNode): void => {\n    const connections = new Map<TNativeAudioNode | TNativeAudioParam, { input: number; output: number }[]>();\n\n    nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            } else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n            disconnect.apply(nativeAudioNode);\n\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    } else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            } else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                } else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter(\n                            (connection) => connection.output !== output && (connection.input !== input || input === undefined)\n                        );\n\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        } else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    } else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n"]},"metadata":{},"sourceType":"module"}