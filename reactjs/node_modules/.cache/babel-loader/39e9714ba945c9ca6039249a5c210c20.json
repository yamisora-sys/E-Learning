{"ast":null,"code":"import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\n\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const {\n    outputs\n  } = getAudioNodeConnections(source);\n  const eventListeners = getEventListenersOfAudioNode(source);\n\n  const eventListener = isActive => {\n    const nativeAudioNode = getNativeAudioNode(source);\n    const nativeAudioParam = getNativeAudioParam(destination);\n\n    if (isActive) {\n      const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n      addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n\n  if (insertElementInSet(outputs, [destination, output], outputConnection => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n    eventListeners.add(eventListener);\n\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioNodeConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n  const {\n    activeInputs,\n    passiveInputs\n  } = getAudioParamConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n\n  if (isActiveAudioNode(destination)) {\n    const {\n      activeInputs\n    } = getAudioNodeConnections(destination);\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\n\nconst deleteInputsOfAudioParam = (source, isOffline, destination, output) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\n\nconst deleteAnyConnection = (source, isOffline) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n    }\n\n    destinations.push(outputConnection[0]);\n  }\n\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\n\nconst deleteConnectionAtOutput = (source, isOffline, output) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (outputConnection[1] === output) {\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n      } else {\n        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n      }\n\n      destinations.push(outputConnection[0]);\n      audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    }\n  }\n\n  return destinations;\n};\n\nconst deleteConnectionToDestination = (source, isOffline, destination, output, input) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter(outputConnection => outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input)).map(outputConnection => {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n    }\n\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\n\nexport const createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) => {\n  return class AudioNode extends eventTargetConstructor {\n    constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      super(nativeAudioNode);\n      this._context = context;\n      this._nativeAudioNode = nativeAudioNode;\n      const nativeContext = getNativeContext(context); // Bug #12: Safari does not support to disconnect a specific destination.\n\n      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n\n      AUDIO_NODE_STORE.set(this, nativeAudioNode);\n      EVENT_LISTENERS.set(this, new Set());\n\n      if (context.state !== 'closed' && isActive) {\n        setInternalStateToActive(this);\n      }\n\n      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n    }\n\n    get channelCount() {\n      return this._nativeAudioNode.channelCount;\n    }\n\n    set channelCount(value) {\n      this._nativeAudioNode.channelCount = value;\n    }\n\n    get channelCountMode() {\n      return this._nativeAudioNode.channelCountMode;\n    }\n\n    set channelCountMode(value) {\n      this._nativeAudioNode.channelCountMode = value;\n    }\n\n    get channelInterpretation() {\n      return this._nativeAudioNode.channelInterpretation;\n    }\n\n    set channelInterpretation(value) {\n      this._nativeAudioNode.channelInterpretation = value;\n    }\n\n    get context() {\n      return this._context;\n    }\n\n    get numberOfInputs() {\n      return this._nativeAudioNode.numberOfInputs;\n    }\n\n    get numberOfOutputs() {\n      return this._nativeAudioNode.numberOfOutputs;\n    } // tslint:disable-next-line:invalid-void\n\n\n    connect(destination) {\n      let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n      if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n\n      const nativeContext = getNativeContext(this._context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n      if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n        throw createInvalidAccessError();\n      }\n\n      if (isAudioNode(destination)) {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n        try {\n          const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n          const isPassive = isPassiveAudioNode(this);\n\n          if (isOffline || isPassive) {\n            this._nativeAudioNode.disconnect(...connection);\n          }\n\n          if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n            setInternalStateToActive(destination);\n          }\n        } catch (err) {\n          // Bug #41: Safari does not throw the correct exception so far.\n          if (err.code === 12) {\n            throw createInvalidAccessError();\n          }\n\n          throw err;\n        }\n\n        const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline); // Bug #164: Only Firefox detects cycles so far.\n\n        if (isNewConnectionToAudioNode) {\n          const cycles = detectCycles([this], destination);\n          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n        }\n\n        return destination;\n      }\n\n      const nativeAudioParam = getNativeAudioParam(destination);\n      /*\n       * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n       * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n       * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n       */\n\n      if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n        throw createNotSupportedError();\n      }\n\n      try {\n        this._nativeAudioNode.connect(nativeAudioParam, output);\n\n        if (isOffline || isPassiveAudioNode(this)) {\n          this._nativeAudioNode.disconnect(nativeAudioParam, output);\n        }\n      } catch (err) {\n        // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n        if (err.code === 12) {\n          throw createInvalidAccessError();\n        }\n\n        throw err;\n      }\n\n      const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline); // Bug #164: Only Firefox detects cycles so far.\n\n      if (isNewConnectionToAudioParam) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n      }\n    }\n\n    disconnect(destinationOrOutput, output, input) {\n      let destinations;\n      const nativeContext = getNativeContext(this._context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n      if (destinationOrOutput === undefined) {\n        destinations = deleteAnyConnection(this, isOffline);\n      } else if (typeof destinationOrOutput === 'number') {\n        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n\n        destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n      } else {\n        if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n          throw createIndexSizeError();\n        }\n\n        if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n          throw createIndexSizeError();\n        }\n\n        destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n        if (destinations.length === 0) {\n          throw createInvalidAccessError();\n        }\n      } // Bug #164: Only Firefox detects cycles so far.\n\n\n      for (const destination of destinations) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n      }\n    }\n\n  };\n};","map":{"version":3,"mappings":"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","names":["AUDIO_NODE_STORE","EVENT_LISTENERS","isAudioNode","isAudioNodeOutputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioParam","connectNativeAudioNodeToNativeAudioNode","deleteActiveInputConnection","deleteActiveInputConnectionToAudioParam","deleteEventListenerOfAudioNode","deletePassiveInputConnectionToAudioNode","deletePassiveInputConnectionToAudioParam","disconnectNativeAudioNodeFromNativeAudioNode","getAudioNodeConnections","getAudioParamConnections","getEventListenersOfAudioNode","getNativeAudioNode","getNativeAudioParam","insertElementInSet","isActiveAudioNode","isPartOfACycle","isPassiveAudioNode","setInternalStateToActive","setInternalStateToPassiveWhenNecessary","testAudioNodeDisconnectMethodSupport","visitEachAudioNodeOnce","wrapAudioNodeDisconnectMethod","addConnectionToAudioParamOfAudioContext","source","destination","output","isOffline","activeInputs","passiveInputs","outputs","eventListeners","eventListener","isActive","nativeAudioNode","nativeAudioParam","partialConnection","connect","disconnect","outputConnection","add","deleteInputConnectionOfAudioNode","input","activeInputConnection","passiveInputConnection","deleteInputConnectionOfAudioParam","deleteInputsOfAudioNode","listener","deleteInputsOfAudioParam","deleteAnyConnection","audioNodeConnectionsOfSource","destinations","push","clear","deleteConnectionAtOutput","delete","deleteConnectionToDestination","Array","from","filter","undefined","map","createAudioNodeConstructor","addAudioNodeConnections","addConnectionToAudioNode","cacheTestResult","createIncrementCycleCounter","createIndexSizeError","createInvalidAccessError","createNotSupportedError","decrementCycleCounter","detectCycles","eventTargetConstructor","getNativeContext","isNativeAudioContext","isNativeAudioNode","isNativeAudioParam","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","AudioNode","constructor","context","audioNodeRenderer","_context","_nativeAudioNode","nativeContext","set","Set","state","channelCount","value","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","nativeDestinationAudioNode","connection","isPassive","err","code","isNewConnectionToAudioNode","cycles","name","maxValue","isNewConnectionToAudioParam","destinationOrOutput","length"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\audio-node-constructor.ts"],"sourcesContent":["import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}