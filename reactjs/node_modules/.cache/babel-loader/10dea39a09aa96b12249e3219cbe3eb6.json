{"ast":null,"code":"import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections) => {\n  return (nativeContext, baseLatency, processorConstructor, options) => {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n\n    const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n\n    if (outputChannelCount.some(channelCount => channelCount < 1)) {\n      throw createNotSupportedError();\n    }\n\n    if (outputChannelCount.length !== options.numberOfOutputs) {\n      throw createIndexSizeError();\n    } // Bug #61: This is not part of the standard but required for the faker to work.\n\n\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.\n\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n\n    const messageChannel = new MessageChannel();\n    const gainNodes = [];\n    const inputChannelSplitterNodes = [];\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n\n    const constantSourceNodes = [];\n\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      for (const {\n        defaultValue,\n        maxValue,\n        minValue,\n        name\n      } of processorConstructor.parameterDescriptors) {\n        const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n          channelCount: 1,\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n        });\n        Object.defineProperties(constantSourceNode.offset, {\n          defaultValue: {\n            get: () => defaultValue === undefined ? 0 : defaultValue\n          },\n          maxValue: {\n            get: () => maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n          },\n          minValue: {\n            get: () => minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n          }\n        });\n        constantSourceNodes.push(constantSourceNode);\n      }\n    }\n\n    const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    const outputChannelMergerNodes = [];\n\n    for (let i = 0; i < options.numberOfOutputs; i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: outputChannelCount[i]\n      }));\n    }\n\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n      for (let j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n      }\n    }\n\n    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map((_ref, index) => {\n      let {\n        name\n      } = _ref;\n      const constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    let channelInterpretation = options.channelInterpretation;\n    let onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.\n\n    const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    const nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return options.channelCount;\n      },\n\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        for (const gainNode of gainNodes) {\n          gainNode.channelInterpretation = value;\n        }\n\n        channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return gainNodes;\n      },\n\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n\n        onprocessorerror = typeof value === 'function' ? value : null;\n\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n\n      get parameters() {\n        return parameterMap;\n      },\n\n      get port() {\n        return messageChannel.port2;\n      },\n\n      addEventListener() {\n        return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n\n      dispatchEvent() {\n        return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n\n      removeEventListener() {\n        return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n\n    };\n    const patchedEventListeners = new Map();\n\n    messageChannel.port1.addEventListener = (addEventListener => {\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (args[0] === 'message') {\n          const unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n          if (unpatchedEventListener !== null) {\n            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = event => {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n              };\n\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.addEventListener);\n\n    messageChannel.port1.removeEventListener = (removeEventListener => {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        if (args[0] === 'message') {\n          const patchedEventListener = patchedEventListeners.get(args[1]);\n\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.removeEventListener);\n\n    let onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: () => onmessage,\n      set: value => {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n\n        onmessage = typeof value === 'function' ? value : null;\n\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    let audioWorkletProcessor = null;\n    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(dWrkltPrcssr => audioWorkletProcessor = dWrkltPrcssr);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, _ref2) => {\n      let {\n        name\n      } = _ref2;\n      return { ...prmtrs,\n        [name]: new Float32Array(128)\n      };\n    }, {});\n    let isActive = true;\n\n    const disconnectOutputsGraph = () => {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n\n      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n        const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n        for (let j = 0; j < outputChannelCount[i]; j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n        }\n\n        outputChannelSplitterNodeOutput += outputChannelCount[i];\n      }\n    };\n\n    const activeInputIndexes = new Map(); // tslint:disable-next-line:deprecation\n\n    scriptProcessorNode.onaudioprocess = _ref3 => {\n      let {\n        inputBuffer,\n        outputBuffer\n      } = _ref3;\n\n      if (audioWorkletProcessor !== null) {\n        const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n        for (let i = 0; i < bufferSize; i += 128) {\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[j], k, k, i);\n            }\n          }\n\n          if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach((_ref4, index) => {\n              let {\n                name\n              } = _ref4;\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n          }\n\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n              // The byteLength will be 0 when the ArrayBuffer was transferred.\n              if (outputs[j][k].byteLength === 0) {\n                outputs[j][k] = new Float32Array(128);\n              }\n            }\n          }\n\n          try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n              const activeInput = activeInputs[index];\n\n              if (activeInput.size > 0) {\n                activeInputIndexes.set(index, bufferSize / 128);\n                return input;\n              }\n\n              const count = activeInputIndexes.get(index);\n\n              if (count === undefined) {\n                return [];\n              }\n\n              if (input.every(channelData => channelData.every(sample => sample === 0))) {\n                if (count === 1) {\n                  activeInputIndexes.delete(index);\n                } else {\n                  activeInputIndexes.set(index, count - 1);\n                }\n              }\n\n              return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            isActive = activeSourceFlag;\n\n            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n              for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n              }\n\n              outputChannelSplitterNodeOutput += outputChannelCount[j];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n              colno: error.colno,\n              filename: error.filename,\n              lineno: error.lineno,\n              message: error.message\n            }));\n          }\n\n          if (!isActive) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n              gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n              for (let k = 0; k < options.channelCount; k += 1) {\n                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              const length = processorConstructor.parameterDescriptors.length;\n\n              for (let j = 0; j < length; j += 1) {\n                const constantSourceNode = constantSourceNodes[j];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                constantSourceNode.stop();\n              }\n            }\n\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            if (isConnected) {\n              disconnectOutputsGraph();\n            } else {\n              disconnectFakeGraph();\n            }\n\n            break;\n          }\n        }\n      }\n    };\n\n    let isConnected = false; // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n\n    const nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n\n    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n    const disconnectFakeGraph = () => {\n      scriptProcessorNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n\n    const whenConnected = () => {\n      if (isActive) {\n        disconnectFakeGraph();\n\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n      }\n\n      isConnected = true;\n    };\n\n    const whenDisconnected = () => {\n      if (isActive) {\n        connectFakeGraph();\n        disconnectOutputsGraph();\n      }\n\n      isConnected = false;\n    };\n\n    connectFakeGraph();\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"mappings":"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","names":["MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","computeBufferSize","copyFromChannel","copyToChannel","createAudioWorkletProcessor","createNestedArrays","ReadOnlyMap","createNativeAudioWorkletNodeFakerFactory","connectMultipleOutputs","createIndexSizeError","createInvalidStateError","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","createNativeScriptProcessorNode","createNotSupportedError","disconnectMultipleOutputs","exposeCurrentFrameAndCurrentTime","getActiveAudioWorkletNodeInputs","monitorConnections","nativeContext","baseLatency","processorConstructor","options","numberOfInputs","numberOfOutputs","outputChannelCount","Array","isArray","from","some","channelCount","length","channelCountMode","numberOfInputChannels","numberOfOutputChannels","reduce","sum","value","numberOfParameters","parameterDescriptors","undefined","messageChannel","MessageChannel","gainNodes","inputChannelSplitterNodes","i","push","channelInterpretation","gain","constantSourceNodes","defaultValue","maxValue","minValue","name","constantSourceNode","offset","parameterData","Object","defineProperties","get","inputChannelMergerNode","Math","max","bufferSize","sampleRate","scriptProcessorNode","outputChannelSplitterNode","outputChannelMergerNodes","connect","j","parameterMap","map","index","start","onprocessorerror","outputAudioNodes","nativeAudioWorkletNodeFaker","_","gainNode","context","inputs","removeEventListener","addEventListener","parameters","port","port2","bind","disconnect","dispatchEvent","patchedEventListeners","Map","port1","args","unpatchedEventListener","handleEvent","patchedEventListener","event","currentTime","set","call","delete","onmessage","defineProperty","prototype","audioWorkletProcessor","audioWorkletProcessorPromise","then","dWrkltPrcssr","outputs","prmtrs","Float32Array","isActive","disconnectOutputsGraph","outputChannelSplitterNodeOutput","outputChannelMergerNode","activeInputIndexes","onaudioprocess","inputBuffer","outputBuffer","activeInputs","k","forEach","byteLength","potentiallyEmptyInputs","input","activeInput","size","count","every","channelData","sample","activeSourceFlag","process","error","ErrorEvent","colno","filename","lineno","message","stop","isConnected","disconnectFakeGraph","nativeGainNode","connectFakeGraph","destination","whenConnected","whenDisconnected"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\native-audio-worklet-node-faker-factory.ts"],"sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { IAudioWorkletProcessor } from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeFakerFactoryFactory,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeConstantSourceNode,\n    TNativeGainNode\n} from '../types';\n\nexport const createNativeAudioWorkletNodeFakerFactory: TNativeAudioWorkletNodeFakerFactoryFactory = (\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters =\n            processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n\n        const messageChannel = new MessageChannel();\n        const gainNodes: TNativeGainNode[] = [];\n        const inputChannelSplitterNodes: TNativeChannelSplitterNode[] = [];\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(\n                createNativeGainNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                })\n            );\n            inputChannelSplitterNodes.push(\n                createNativeChannelSplitterNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: options.channelCount\n                })\n            );\n        }\n\n        const constantSourceNodes: TNativeConstantSourceNode[] = [];\n\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset:\n                        options.parameterData[name] !== undefined\n                            ? options.parameterData[name]\n                            : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(\n            nativeContext,\n            bufferSize,\n            numberOfInputChannels + numberOfParameters,\n            // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n            Math.max(1, numberOfOutputChannels)\n        );\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(\n                createNativeChannelMergerNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: outputChannelCount[i]\n                })\n            );\n        }\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n\n        const parameterMap = new ReadOnlyMap(\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                      const constantSourceNode = constantSourceNodes[index];\n\n                      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                      constantSourceNode.start(0);\n\n                      return <[string, TNativeAudioParam]>[name, constantSourceNode.offset];\n                  })\n        );\n\n        inputChannelMergerNode.connect(scriptProcessorNode);\n\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode(): TNativeAudioWorkletNode['channelCountMode'] {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation(): TNativeAudioWorkletNode['channelInterpretation'] {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n\n                channelInterpretation = value;\n            },\n            get context(): TNativeAudioWorkletNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return gainNodes;\n            },\n            get numberOfInputs(): number {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror(): TNativeAudioWorkletNode['onprocessorerror'] {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n\n                onprocessorerror = typeof value === 'function' ? value : null;\n\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters(): TNativeAudioWorkletNode['parameters'] {\n                return parameterMap;\n            },\n            get port(): TNativeAudioWorkletNode['port'] {\n                return messageChannel.port2;\n            },\n            addEventListener(...args: any[]): void {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        const patchedEventListeners: Map<EventListenerOrEventListenerObject, NonNullable<MessagePort['onmessage']>> = new Map();\n\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener =\n                        typeof args[1] === 'function'\n                            ? args[1]\n                            : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                        if (patchedEventListener !== undefined) {\n                            args[1] = <EventListenerOrEventListenerObject>patchedEventListener;\n                        } else {\n                            args[1] = (event: Event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                                    unpatchedEventListener(event)\n                                );\n                            };\n\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args: any[]): void => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n\n                        args[1] = patchedEventListener;\n                    }\n                }\n\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n\n        let onmessage: MessagePort['onmessage'] = null;\n\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n\n                onmessage = typeof value === 'function' ? value : null;\n\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n\n        processorConstructor.prototype.port = messageChannel.port1;\n\n        let audioWorkletProcessor: null | IAudioWorkletProcessor = null;\n\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(\n            nativeContext,\n            nativeAudioWorkletNodeFaker,\n            processorConstructor,\n            options\n        );\n\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters: { [name: string]: Float32Array } =\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.reduce(\n                      (prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n                      {}\n                  );\n\n        let isActive = true;\n\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n\n        const activeInputIndexes = new Map<number, number>();\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }: AudioProcessingEvent) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n\n                                return input;\n                            }\n\n                            const count = activeInputIndexes.get(index);\n\n                            if (count === undefined) {\n                                return [];\n                            }\n\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                } else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n\n                            return input;\n                        });\n\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                            nativeContext.currentTime + i / nativeContext.sampleRate,\n                            nativeContext.sampleRate,\n                            () => (<IAudioWorkletProcessor>audioWorkletProcessor).process(potentiallyEmptyInputs, outputs, parameters)\n                        );\n\n                        isActive = activeSourceFlag;\n\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    } catch (error) {\n                        isActive = false;\n\n                        nativeAudioWorkletNodeFaker.dispatchEvent(\n                            new ErrorEvent('processorerror', {\n                                colno: error.colno,\n                                filename: error.filename,\n                                lineno: error.lineno,\n                                message: error.message\n                            })\n                        );\n                    }\n\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        } else {\n                            disconnectFakeGraph();\n                        }\n\n                        break;\n                    }\n                }\n            }\n        };\n\n        let isConnected = false;\n\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n\n            isConnected = false;\n        };\n\n        connectFakeGraph();\n\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n"]},"metadata":{},"sourceType":"module"}