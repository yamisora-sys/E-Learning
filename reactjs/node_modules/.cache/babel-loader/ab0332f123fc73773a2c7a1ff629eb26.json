{"ast":null,"code":"export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = nativeAudioBufferSourceNode => {\n  nativeAudioBufferSourceNode.start = (start => {\n    return function () {\n      let when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let duration = arguments.length > 2 ? arguments[2] : undefined;\n      const buffer = nativeAudioBufferSourceNode.buffer; // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n\n      const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset); // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n\n      if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n        start.call(nativeAudioBufferSourceNode, when, 0, 0);\n      } else {\n        start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n      }\n    };\n  })(nativeAudioBufferSourceNode.start);\n};","map":{"version":3,"mappings":"AAEA,OAAO,MAAMA,kDAAkD,GAAIC,2BAAD,IAAoE;EAClIA,2BAA2B,CAACC,KAA5B,GAAoC,CAAEA,KAAD,IAAU;IAC3C,OAAO,YAA4C;MAAA,IAA3CC,IAA2C,uEAApC,CAAoC;MAAA,IAAjCC,MAAiC,uEAAxB,CAAwB;MAAA,IAArBC,QAAqB;MAC/C,MAAMC,MAAM,GAAGL,2BAA2B,CAACK,MAA3C,CAD+C,CAE/C;;MACA,MAAMC,aAAa,GAAGD,MAAM,KAAK,IAAX,GAAkBF,MAAlB,GAA2BI,IAAI,CAACC,GAAL,CAASH,MAAM,CAACD,QAAhB,EAA0BD,MAA1B,CAAjD,CAH+C,CAK/C;;MACA,IAAIE,MAAM,KAAK,IAAX,IAAmBC,aAAa,GAAGD,MAAM,CAACD,QAAP,GAAkB,MAAMJ,2BAA2B,CAACS,OAA5B,CAAoCC,UAAnG,EAA+G;QAC3GT,KAAK,CAACU,IAAN,CAAWX,2BAAX,EAAwCE,IAAxC,EAA8C,CAA9C,EAAiD,CAAjD;MACH,CAFD,MAEO;QACHD,KAAK,CAACU,IAAN,CAAWX,2BAAX,EAAwCE,IAAxC,EAA8CI,aAA9C,EAA6DF,QAA7D;MACH;IACJ,CAXD;EAYH,CAbmC,EAajCJ,2BAA2B,CAACC,KAbK,CAApC;AAcH,CAfM","names":["wrapAudioBufferSourceNodeStartMethodOffsetClamping","nativeAudioBufferSourceNode","start","when","offset","duration","buffer","clampedOffset","Math","min","context","sampleRate","call"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\helpers\\wrap-audio-buffer-source-node-start-method-offset-clamping.ts"],"sourcesContent":["import { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            } else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n"]},"metadata":{},"sourceType":"module"}