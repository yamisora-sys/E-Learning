{"ast":null,"code":"import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  parameterData: {},\n  processorOptions: {}\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) => {\n  return class AudioWorkletNode extends audioNodeConstructor {\n    constructor(context, name, options) {\n      var _a;\n\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS,\n        ...options\n      }); // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n\n      testAudioWorkletNodeOptionsClonability(mergedOptions);\n      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name); // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n\n      const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed' ? nativeContext : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n      const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n\n      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      const parameters = [];\n      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n        const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      this._onprocessorerror = null;\n      this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, this);\n      }\n\n      const {\n        activeInputs\n      } = getAudioNodeConnections(this);\n      setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n    }\n\n    get onprocessorerror() {\n      return this._onprocessorerror;\n    }\n\n    set onprocessorerror(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n    }\n\n    get parameters() {\n      if (this._parameters === null) {\n        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n        return this._nativeAudioWorkletNode.parameters;\n      }\n\n      return this._parameters;\n    }\n\n    get port() {\n      return this._nativeAudioWorkletNode.port;\n    }\n\n  };\n};","map":{"version":3,"mappings":"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","names":["NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","ReadOnlyMap","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","parameterData","processorOptions","createAudioWorkletNodeConstructor","addUnrenderedAudioWorkletNode","audioNodeConstructor","createAudioParam","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","getAudioNodeConnections","getBackupOfflineAudioContext","getNativeContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","sanitizeAudioWorkletNodeOptions","setActiveAudioWorkletNodeInputs","testAudioWorkletNodeOptionsClonability","wrapEventListener","AudioWorkletNode","constructor","context","name","options","nativeContext","isOffline","mergedOptions","nodeNameToProcessorConstructorMap","get","processorConstructor","nativeContextOrBackupOfflineAudioContext","state","_a","nativeAudioWorkletNode","baseLatency","audioWorkletNodeRenderer","parameters","forEach","nativeAudioParam","nm","audioParam","push","_nativeAudioWorkletNode","_onprocessorerror","_parameters","activeInputs","onprocessorerror","value","wrappedListener","nativeOnProcessorError","port"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\audio-worklet-node-constructor.ts"],"sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport {\n    IAudioParam,\n    IAudioWorkletNode,\n    IAudioWorkletNodeEventMap,\n    IAudioWorkletNodeOptions,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TAudioNodeRenderer,\n    TAudioParamMap,\n    TAudioWorkletNodeConstructorFactory,\n    TContext,\n    TErrorEventHandler,\n    TNativeAudioContext,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n} as const;\n\nexport const createAudioWorkletNodeConstructor: TAudioWorkletNodeConstructorFactory = (\n    addUnrenderedAudioWorkletNode,\n    audioNodeConstructor,\n    createAudioParam,\n    createAudioWorkletNodeRenderer,\n    createNativeAudioWorkletNode,\n    getAudioNodeConnections,\n    getBackupOfflineAudioContext,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    sanitizeAudioWorkletNodeOptions,\n    setActiveAudioWorkletNodeInputs,\n    testAudioWorkletNodeOptionsClonability,\n    wrapEventListener\n) => {\n    return class AudioWorkletNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioWorkletNodeEventMap>\n        implements IAudioWorkletNode<T>\n    {\n        private _nativeAudioWorkletNode: TNativeAudioWorkletNode;\n\n        private _onprocessorerror: null | TErrorEventHandler<this>;\n\n        private _parameters: null | TAudioParamMap;\n\n        constructor(context: T, name: string, options?: Partial<IAudioWorkletNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap?.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext =\n                isOffline || nativeContext.state !== 'closed'\n                    ? nativeContext\n                    : getBackupOfflineAudioContext(<TNativeAudioContext>nativeContext) ?? nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(\n                nativeContextOrBackupOfflineAudioContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                nativeAudioWorkletNodeConstructor,\n                name,\n                processorConstructor,\n                mergedOptions\n            );\n            const audioWorkletNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null)\n            );\n\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n\n            const parameters: [string, IAudioParam][] = [];\n\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n\n                parameters.push([nm, audioParam]);\n            });\n\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, <IAudioWorkletNode<IMinimalOfflineAudioContext | IOfflineAudioContext>>this);\n            }\n\n            const { activeInputs } = getAudioNodeConnections(this);\n\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n\n        get onprocessorerror(): null | TErrorEventHandler<this> {\n            return this._onprocessorerror;\n        }\n\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, <EventListenerOrEventListenerObject>value) : null;\n\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : <null | TErrorEventHandler<this>>nativeOnProcessorError;\n        }\n\n        get parameters(): TAudioParamMap {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return <IReadOnlyMap<string, TNativeAudioParam>>this._nativeAudioWorkletNode.parameters;\n            }\n\n            return this._parameters;\n        }\n\n        get port(): MessagePort {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}