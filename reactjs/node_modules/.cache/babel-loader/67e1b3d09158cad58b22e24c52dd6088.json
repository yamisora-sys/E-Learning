{"ast":null,"code":"import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nexport const createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode) => {\n  const tailTimeTimeoutIds = new WeakMap();\n  return (source, destination, output, input, isOffline) => {\n    const {\n      activeInputs,\n      passiveInputs\n    } = getAudioNodeConnections(destination);\n    const {\n      outputs\n    } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener = isActive => {\n      const nativeDestinationAudioNode = getNativeAudioNode(destination);\n      const nativeSourceAudioNode = getNativeAudioNode(source);\n\n      if (isActive) {\n        const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n        if (!isOffline && !isPartOfACycle(source)) {\n          connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n        }\n\n        if (isPassiveAudioNode(destination)) {\n          setInternalStateToActive(destination);\n        }\n      } else {\n        const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n        addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n        if (!isOffline && !isPartOfACycle(source)) {\n          disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n        }\n\n        const tailTime = getAudioNodeTailTime(destination);\n\n        if (tailTime === 0) {\n          if (isActiveAudioNode(destination)) {\n            setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n          }\n        } else {\n          const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n\n          if (tailTimeTimeoutId !== undefined) {\n            clearTimeout(tailTimeTimeoutId);\n          }\n\n          tailTimeTimeoutIds.set(destination, setTimeout(() => {\n            if (isActiveAudioNode(destination)) {\n              setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n            }\n          }, tailTime * 1000));\n        }\n      }\n    };\n\n    if (insertElementInSet(outputs, [destination, output, input], outputConnection => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n      eventListeners.add(eventListener);\n\n      if (isActiveAudioNode(source)) {\n        addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n      } else {\n        addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n};","map":{"version":3,"mappings":"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","names":["deletePassiveInputConnectionToAudioNode","setInternalStateToActive","setInternalStateToPassiveWhenNecessary","createAddConnectionToAudioNode","addActiveInputConnectionToAudioNode","addPassiveInputConnectionToAudioNode","connectNativeAudioNodeToNativeAudioNode","deleteActiveInputConnectionToAudioNode","disconnectNativeAudioNodeFromNativeAudioNode","getAudioNodeConnections","getAudioNodeTailTime","getEventListenersOfAudioNode","getNativeAudioNode","insertElementInSet","isActiveAudioNode","isPartOfACycle","isPassiveAudioNode","tailTimeTimeoutIds","WeakMap","source","destination","output","input","isOffline","activeInputs","passiveInputs","outputs","eventListeners","eventListener","isActive","nativeDestinationAudioNode","nativeSourceAudioNode","partialConnection","tailTime","tailTimeTimeoutId","get","undefined","clearTimeout","set","setTimeout","outputConnection","add"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\add-connection-to-audio-node.ts"],"sourcesContent":["import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { IAudioNode } from '../interfaces';\nimport { TAddConnectionToAudioNodeFactory, TContext, TInternalStateEventListener } from '../types';\n\nexport const createAddConnectionToAudioNode: TAddConnectionToAudioNodeFactory = (\n    addActiveInputConnectionToAudioNode,\n    addPassiveInputConnectionToAudioNode,\n    connectNativeAudioNodeToNativeAudioNode,\n    deleteActiveInputConnectionToAudioNode,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getAudioNodeTailTime,\n    getEventListenersOfAudioNode,\n    getNativeAudioNode,\n    insertElementInSet,\n    isActiveAudioNode,\n    isPartOfACycle,\n    isPassiveAudioNode\n) => {\n    const tailTimeTimeoutIds = new WeakMap<IAudioNode<TContext>, number>();\n\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n\n        const eventListener: TInternalStateEventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            } else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                const tailTime = getAudioNodeTailTime(destination);\n\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                } else {\n                    const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n\n                    if (tailTimeTimeoutId !== undefined) {\n                        clearTimeout(tailTimeTimeoutId);\n                    }\n\n                    tailTimeTimeoutIds.set(\n                        destination,\n                        setTimeout(() => {\n                            if (isActiveAudioNode(destination)) {\n                                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                            }\n                        }, tailTime * 1000)\n                    );\n                }\n            }\n        };\n\n        if (\n            insertElementInSet(\n                outputs,\n                [destination, output, input],\n                (outputConnection) =>\n                    outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input,\n                true\n            )\n        ) {\n            eventListeners.add(eventListener);\n\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            } else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n\n            return true;\n        }\n\n        return false;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}