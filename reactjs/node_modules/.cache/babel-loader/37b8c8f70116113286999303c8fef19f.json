{"ast":null,"code":"import { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeAudioNodes = new WeakMap();\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n      let nativeAudioNode = getNativeAudioNode(proxy); // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n      if (!nativeAudioNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeAudioNode.channelCount,\n          channelCountMode: nativeAudioNode.channelCountMode,\n          channelInterpretation: nativeAudioNode.channelInterpretation,\n          numberOfInputs: nativeAudioNode.numberOfInputs\n        };\n        nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n      return nativeAudioNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext) {\n        const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext);\n      }\n\n    };\n  };\n};","map":{"version":3,"mappings":"AAAA,SAASA,gBAAT,QAAiC,gCAAjC;AAIA,OAAO,MAAMC,sCAAsC,GAA6C,CAC5FC,6BAD4F,EAE5FC,kBAF4F,EAG5FC,uBAH4F,KAI5F;EACA,OAAO,MAAmE;IACtE,MAAMC,wBAAwB,GAAG,IAAIC,OAAJ,EAAjC;;IAEA,MAAMC,eAAe,GAAG,OAAOC,KAAP,EAA6BC,yBAA7B,KAAsF;MAC1G,IAAIC,eAAe,GAAGP,kBAAkB,CAAsBK,KAAtB,CAAxC,CAD0G,CAG1G;;MACA,MAAMG,+BAA+B,GAAGX,gBAAgB,CAACU,eAAD,EAAkBD,yBAAlB,CAAxD;;MAEA,IAAI,CAACE,+BAAL,EAAsC;QAClC,MAAMC,OAAO,GAAG;UACZC,YAAY,EAAEH,eAAe,CAACG,YADlB;UAEZC,gBAAgB,EAAEJ,eAAe,CAACI,gBAFtB;UAGZC,qBAAqB,EAAEL,eAAe,CAACK,qBAH3B;UAIZC,cAAc,EAAEN,eAAe,CAACM;QAJpB,CAAhB;QAOAN,eAAe,GAAGR,6BAA6B,CAACO,yBAAD,EAA4BG,OAA5B,CAA/C;MACH;;MAEDP,wBAAwB,CAACY,GAAzB,CAA6BR,yBAA7B,EAAwDC,eAAxD;MAEA,MAAMN,uBAAuB,CAACI,KAAD,EAAQC,yBAAR,EAAmCC,eAAnC,CAA7B;MAEA,OAAOA,eAAP;IACH,CAtBD;;IAwBA,OAAO;MACHQ,MAAM,CAACV,KAAD,EAAuBC,yBAAvB,EAA4E;QAC9E,MAAMU,uBAAuB,GAAGd,wBAAwB,CAACe,GAAzB,CAA6BX,yBAA7B,CAAhC;;QAEA,IAAIU,uBAAuB,KAAKE,SAAhC,EAA2C;UACvC,OAAOC,OAAO,CAACC,OAAR,CAAgBJ,uBAAhB,CAAP;QACH;;QAED,OAAOZ,eAAe,CAACC,KAAD,EAAQC,yBAAR,CAAtB;MACH;;IATE,CAAP;EAWH,CAtCD;AAuCH,CA5CM","names":["isOwnedByContext","createChannelMergerNodeRendererFactory","createNativeChannelMergerNode","getNativeAudioNode","renderInputsOfAudioNode","renderedNativeAudioNodes","WeakMap","createAudioNode","proxy","nativeOfflineAudioContext","nativeAudioNode","nativeAudioNodeIsOwnedByContext","options","channelCount","channelCountMode","channelInterpretation","numberOfInputs","set","render","renderedNativeAudioNode","get","undefined","Promise","resolve"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\channel-merger-node-renderer-factory.ts"],"sourcesContent":["import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelMergerNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelMergerNodeRendererFactory: TChannelMergerNodeRendererFactoryFactory = (\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}