{"ast":null,"code":"import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n  // Ceil the length to the next full render quantum.\n  // Bug #17: Safari does not yet expose the length.\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n  if (processorConstructor === undefined) {\n    throw new Error('Missing the processor constructor.');\n  }\n\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs,\n    [name]: new Float32Array(128)\n  }), {});\n\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n\n    if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach((_ref, index) => {\n        let {\n          name\n        } = _ref;\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < outputChannelCount[j]; k += 1) {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [];\n        }\n\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n\n          outputChannelSplitterNodeOutput += outputChannelCount[j];\n        }\n      }\n\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent('processorerror', {\n        colno: error.colno,\n        filename: error.filename,\n        lineno: error.lineno,\n        message: error.message\n      }));\n      break;\n    }\n  }\n\n  return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = new WeakMap();\n    let processedBufferPromise = null;\n\n    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n      let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n      const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n\n      if (nativeAudioWorkletNodeConstructor === null) {\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: 'explicit',\n          channelInterpretation: 'discrete',\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: outputChannelCount[i]\n          }));\n        }\n\n        const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n      }\n\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === undefined) {\n            throw new Error('Missing the processor constructor.');\n          }\n\n          if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n          } // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n\n\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n              }));\n            }\n\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam => {\n              const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                offset: audioParam.value\n              });\n              await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: 'explicit',\n              channelInterpretation: 'speakers',\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map(gainNode => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)));\n            return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n          };\n\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime);\n        }\n\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: 'max',\n          channelInterpretation: 'speakers',\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n\n        return outputGainNode;\n      }\n\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm));\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          nativeAudioWorkletNode.parameters.get(nm));\n        }\n      }\n\n      await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n      return nativeAudioWorkletNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext);\n      }\n\n    };\n  };\n};","map":{"version":3,"mappings":"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","names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","outputChannelCount","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","i","j","k","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","error","dispatchEvent","ErrorEvent","colno","filename","lineno","message","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","isArray","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","constantSourceNodes","Promise","all","values","audioParam","constantSourceNode","offset","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","loop","loopEnd","loopStart","playbackRate","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\audio-worklet-node-renderer-factory.ts"],"sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport {\n    IAudioWorkletNode,\n    IAudioWorkletNodeOptions,\n    IAudioWorkletProcessorConstructor,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport {\n    TAudioWorkletNodeRendererFactoryFactory,\n    TExposeCurrentFrameAndCurrentTimeFunction,\n    TNativeAudioBuffer,\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeGainNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst processBuffer = async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n    proxy: IAudioWorkletNode<T>,\n    renderedBuffer: null | TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    options: IAudioWorkletNodeOptions,\n    outputChannelCount: number[],\n    processorConstructor: undefined | IAudioWorkletProcessorConstructor,\n    exposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFunction\n): Promise<null | TNativeAudioBuffer> => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer =\n        numberOfOutputChannels === 0\n            ? null\n            : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters: { [name: string]: Float32Array } = Array.from(proxy.parameters.keys()).reduce(\n        (prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n        {}\n    );\n\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                i / nativeOfflineAudioContext.sampleRate,\n                nativeOfflineAudioContext.sampleRate,\n                () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters)\n            );\n\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n\n            if (!activeSourceFlag) {\n                break;\n            }\n        } catch (error) {\n            proxy.dispatchEvent(\n                new ErrorEvent('processorerror', {\n                    colno: error.colno,\n                    filename: error.filename,\n                    lineno: error.lineno,\n                    message: error.message\n                })\n            );\n\n            break;\n        }\n    }\n\n    return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory: TAudioWorkletNodeRendererFactoryFactory = (\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        name: string,\n        options: IAudioWorkletNodeOptions,\n        processorConstructor: undefined | IAudioWorkletProcessorConstructor\n    ) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioWorkletNode | TNativeGainNode>();\n\n        let processedBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IAudioWorkletNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n            let nativeOutputNodes: null | [TNativeChannelSplitterNode, TNativeChannelMergerNode[], TNativeGainNode] = null;\n\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(\n                        createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: outputChannelCount[i]\n                        })\n                    );\n                }\n\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n\n                outputGainNode.connect = <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]\n            );\n\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters =\n                        processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                            numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128,\n                            nativeOfflineAudioContext.sampleRate\n                        );\n                        const gainNodes: TNativeGainNode[] = [];\n                        const inputChannelSplitterNodes = [];\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(\n                                createNativeGainNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: options.channelCountMode,\n                                    channelInterpretation: options.channelInterpretation,\n                                    gain: 1\n                                })\n                            );\n                            inputChannelSplitterNodes.push(\n                                createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    numberOfOutputs: options.channelCount\n                                })\n                            );\n                        }\n\n                        const constantSourceNodes = await Promise.all(\n                            Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                                const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n\n                                return constantSourceNode;\n                            })\n                        );\n\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                        await Promise.all(\n                            gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode))\n                        );\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n\n                    processedBufferPromise = processBuffer(\n                        proxy,\n                        numberOfChannels === 0 ? null : await renderBuffer(),\n                        nativeOfflineAudioContext,\n                        options,\n                        outputChannelCount,\n                        processorConstructor,\n                        exposeCurrentFrameAndCurrentTime\n                    );\n                }\n\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n\n                return outputGainNode;\n            }\n\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            } else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n\n            return nativeAudioWorkletNode;\n        };\n\n        return {\n            render(\n                proxy: IAudioWorkletNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioWorkletNode | TNativeGainNode> {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}