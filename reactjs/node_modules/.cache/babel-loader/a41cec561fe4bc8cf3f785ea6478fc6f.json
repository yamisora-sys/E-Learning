{"ast":null,"code":"import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\n\nconst verifyParameterDescriptors = parameterDescriptors => {\n  if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n    throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n  }\n};\n\nconst verifyProcessorCtor = processorCtor => {\n  if (!isConstructible(processorCtor)) {\n    throw new TypeError('The given value for processorCtor should be a constructor.');\n  }\n\n  if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n    throw new TypeError('The given value for processorCtor should have a prototype.');\n  }\n};\n\nexport const createAddAudioWorkletModule = (cacheTestResult, createNotSupportedError, evaluateSource, exposeCurrentFrameAndCurrentTime, fetchSource, getNativeContext, getOrCreateBackupOfflineAudioContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window) => {\n  let index = 0;\n  return function (context, moduleURL) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      credentials: 'omit'\n    };\n    const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n    if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n      return Promise.resolve();\n    }\n\n    const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n    if (ongoingRequestsOfContext !== undefined) {\n      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n      if (promiseOfOngoingRequest !== undefined) {\n        return promiseOfOngoingRequest;\n      }\n    }\n\n    const nativeContext = getNativeContext(context); // Bug #59: Safari does not implement the audioWorklet property.\n\n    const promise = nativeContext.audioWorklet === undefined ? fetchSource(moduleURL).then(_ref => {\n      let [source, absoluteUrl] = _ref;\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      /*\n       * This is the unminified version of the code used below:\n       *\n       * ```js\n       * ${ importStatements };\n       * ((a, b) => {\n       *     (a[b] = a[b] || [ ]).push(\n       *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n       *             ${ sourceWithoutImportStatements }\n       *         }\n       *     );\n       * })(window, '_AWGS');\n       * ```\n       */\n      // tslint:disable-next-line:max-line-length\n\n      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`; // @todo Evaluating the given source code is a possible security problem.\n\n      return evaluateSource(wrappedSource);\n    }).then(() => {\n      const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n\n      if (evaluateAudioWorkletGlobalScope === undefined) {\n        // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n        throw new SyntaxError();\n      }\n\n      exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {}, undefined, (name, processorCtor) => {\n        if (name.trim() === '') {\n          throw createNotSupportedError();\n        }\n\n        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n        if (nodeNameToProcessorConstructorMap !== undefined) {\n          if (nodeNameToProcessorConstructorMap.has(name)) {\n            throw createNotSupportedError();\n          }\n\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n        } else {\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n        }\n      }, nativeContext.sampleRate, undefined, undefined));\n    }) : Promise.all([fetchSource(moduleURL), Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))]).then(_ref2 => {\n      let [[source, absoluteUrl], isSupportingPostMessage] = _ref2;\n      const currentIndex = index + 1;\n      index = currentIndex;\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      /*\n       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n       *\n       * This is the unminified version of the code used below.\n       *\n       * ```js\n       * class extends AudioWorkletProcessor {\n       *\n       *     __buffers = new WeakSet();\n       *\n       *     constructor () {\n       *         super();\n       *\n       *         this.port.postMessage = ((postMessage) => {\n       *             return (message, transferables) => {\n       *                 const filteredTransferables = (transferables)\n       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n       *                     : transferables;\n       *\n       *                 return postMessage.call(this.port, message, filteredTransferables);\n       *              };\n       *         })(this.port.postMessage);\n       *     }\n       * }\n       * ```\n       */\n\n      const patchedAudioWorkletProcessor = isSupportingPostMessage ? 'AudioWorkletProcessor' : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n      /*\n       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n       *\n       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n       *\n       * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n       *\n       * This is the unminified version of the code used below:\n       *\n       * ```js\n       * `${ importStatements };\n       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n       * })(\n       *     ${ patchedAudioWorkletProcessor },\n       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n       *\n       *         __collectBuffers = (array) => {\n       *             array.forEach((element) => this.__buffers.add(element.buffer));\n       *         };\n       *\n       *         process (inputs, outputs, parameters) {\n       *             inputs.forEach(this.__collectBuffers);\n       *             outputs.forEach(this.__collectBuffers);\n       *             this.__collectBuffers(Object.values(parameters));\n       *\n       *             return super.process(\n       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n       *                 outputs,\n       *                 parameters\n       *             );\n       *         }\n       *\n       *     })\n       * );\n       *\n       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n       *\n       *     process () {\n       *         return false;\n       *     }\n       *\n       * })`\n       * ```\n       */\n\n      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n      const bufferRegistration = isSupportingPostMessage ? '' : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n      const blob = new Blob([wrappedSource], {\n        type: 'application/javascript; charset=utf-8'\n      });\n      const url = URL.createObjectURL(blob);\n      return nativeContext.audioWorklet.addModule(url, options).then(() => {\n        if (isNativeOfflineAudioContext(nativeContext)) {\n          return nativeContext;\n        } // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n\n\n        const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n        return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n      }).then(nativeContextOrBackupOfflineAudioContext => {\n        if (nativeAudioWorkletNodeConstructor === null) {\n          throw new SyntaxError();\n        }\n\n        try {\n          // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n          new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n        } catch {\n          throw new SyntaxError();\n        }\n      }).finally(() => URL.revokeObjectURL(url));\n    });\n\n    if (ongoingRequestsOfContext === undefined) {\n      ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n    } else {\n      ongoingRequestsOfContext.set(moduleURL, promise);\n    }\n\n    promise.then(() => {\n      const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n\n      if (updatedResolvedRequestsOfContext === undefined) {\n        resolvedRequests.set(context, new Set([moduleURL]));\n      } else {\n        updatedResolvedRequestsOfContext.add(moduleURL);\n      }\n    }).finally(() => {\n      const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n\n      if (updatedOngoingRequestsOfContext !== undefined) {\n        updatedOngoingRequestsOfContext.delete(moduleURL);\n      }\n    });\n    return promise;\n  };\n};","map":{"version":3,"mappings":"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","names":["NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","isConstructible","splitImportStatements","verifyParameterDescriptors","parameterDescriptors","undefined","Array","isArray","TypeError","verifyProcessorCtor","processorCtor","prototype","createAddAudioWorkletModule","cacheTestResult","createNotSupportedError","evaluateSource","exposeCurrentFrameAndCurrentTime","fetchSource","getNativeContext","getOrCreateBackupOfflineAudioContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","ongoingRequests","resolvedRequests","testAudioWorkletProcessorPostMessageSupport","window","index","context","moduleURL","options","credentials","resolvedRequestsOfContext","get","has","Promise","resolve","ongoingRequestsOfContext","promiseOfOngoingRequest","nativeContext","promise","audioWorklet","then","source","absoluteUrl","importStatements","sourceWithoutImportStatements","wrappedSource","evaluateAudioWorkletGlobalScope","_AWGS","pop","SyntaxError","currentTime","sampleRate","AudioWorkletProcessor","name","trim","nodeNameToProcessorConstructorMap","set","Map","all","isSupportingPostMessage","currentIndex","patchedAudioWorkletProcessor","memberDefinition","bufferRegistration","blob","Blob","type","url","URL","createObjectURL","addModule","backupOfflineAudioContext","nativeContextOrBackupOfflineAudioContext","finally","revokeObjectURL","updatedResolvedRequestsOfContext","Set","add","updatedOngoingRequestsOfContext","delete"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\add-audio-worklet-module.ts"],"sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nimport { IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TAddAudioWorkletModuleFactory, TEvaluateAudioWorkletGlobalScopeFunction } from '../types';\n\nconst verifyParameterDescriptors = (parameterDescriptors: IAudioWorkletProcessorConstructor['parameterDescriptors']) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\n\nconst verifyProcessorCtor = <T extends IAudioWorkletProcessorConstructor>(processorCtor: T) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\n\nexport const createAddAudioWorkletModule: TAddAudioWorkletModuleFactory = (\n    cacheTestResult,\n    createNotSupportedError,\n    evaluateSource,\n    exposeCurrentFrameAndCurrentTime,\n    fetchSource,\n    getNativeContext,\n    getOrCreateBackupOfflineAudioContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    ongoingRequests,\n    resolvedRequests,\n    testAudioWorkletProcessorPostMessageSupport,\n    window\n) => {\n    let index = 0;\n\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n\n        const nativeContext = getNativeContext(context);\n\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise =\n            nativeContext.audioWorklet === undefined\n                ? fetchSource(moduleURL)\n                      .then(([source, absoluteUrl]) => {\n                          const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n\n                          /*\n                           * This is the unminified version of the code used below:\n                           *\n                           * ```js\n                           * ${ importStatements };\n                           * ((a, b) => {\n                           *     (a[b] = a[b] || [ ]).push(\n                           *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                           *             ${ sourceWithoutImportStatements }\n                           *         }\n                           *     );\n                           * })(window, '_AWGS');\n                           * ```\n                           */\n                          // tslint:disable-next-line:max-line-length\n                          const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n\n                          // @todo Evaluating the given source code is a possible security problem.\n                          return evaluateSource(wrappedSource);\n                      })\n                      .then(() => {\n                          const evaluateAudioWorkletGlobalScope = (<TEvaluateAudioWorkletGlobalScopeFunction[]>(<any>window)._AWGS).pop();\n\n                          if (evaluateAudioWorkletGlobalScope === undefined) {\n                              // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                              throw new SyntaxError();\n                          }\n\n                          exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                              evaluateAudioWorkletGlobalScope(\n                                  class AudioWorkletProcessor {},\n                                  undefined,\n                                  (name, processorCtor) => {\n                                      if (name.trim() === '') {\n                                          throw createNotSupportedError();\n                                      }\n\n                                      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n                                      if (nodeNameToProcessorConstructorMap !== undefined) {\n                                          if (nodeNameToProcessorConstructorMap.has(name)) {\n                                              throw createNotSupportedError();\n                                          }\n\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                                      } else {\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                                      }\n                                  },\n                                  nativeContext.sampleRate,\n                                  undefined,\n                                  undefined\n                              )\n                          );\n                      })\n                : Promise.all([\n                      fetchSource(moduleURL),\n                      Promise.resolve(\n                          cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport)\n                      )\n                  ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                      const currentIndex = index + 1;\n\n                      index = currentIndex;\n\n                      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                      /*\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * This is the unminified version of the code used below.\n                       *\n                       * ```js\n                       * class extends AudioWorkletProcessor {\n                       *\n                       *     __buffers = new WeakSet();\n                       *\n                       *     constructor () {\n                       *         super();\n                       *\n                       *         this.port.postMessage = ((postMessage) => {\n                       *             return (message, transferables) => {\n                       *                 const filteredTransferables = (transferables)\n                       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                       *                     : transferables;\n                       *\n                       *                 return postMessage.call(this.port, message, filteredTransferables);\n                       *              };\n                       *         })(this.port.postMessage);\n                       *     }\n                       * }\n                       * ```\n                       */\n                      const patchedAudioWorkletProcessor = isSupportingPostMessage\n                          ? 'AudioWorkletProcessor'\n                          : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                      /*\n                       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                       *\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                       *\n                       * This is the unminified version of the code used below:\n                       *\n                       * ```js\n                       * `${ importStatements };\n                       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                       * })(\n                       *     ${ patchedAudioWorkletProcessor },\n                       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                       *\n                       *         __collectBuffers = (array) => {\n                       *             array.forEach((element) => this.__buffers.add(element.buffer));\n                       *         };\n                       *\n                       *         process (inputs, outputs, parameters) {\n                       *             inputs.forEach(this.__collectBuffers);\n                       *             outputs.forEach(this.__collectBuffers);\n                       *             this.__collectBuffers(Object.values(parameters));\n                       *\n                       *             return super.process(\n                       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                       *                 outputs,\n                       *                 parameters\n                       *             );\n                       *         }\n                       *\n                       *     })\n                       * );\n                       *\n                       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                       *\n                       *     process () {\n                       *         return false;\n                       *     }\n                       *\n                       * })`\n                       * ```\n                       */\n                      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                      const bufferRegistration = isSupportingPostMessage\n                          ? ''\n                          : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                      const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                      const url = URL.createObjectURL(blob);\n\n                      return nativeContext.audioWorklet\n                          .addModule(url, options)\n                          .then(() => {\n                              if (isNativeOfflineAudioContext(nativeContext)) {\n                                  return nativeContext;\n                              }\n\n                              // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n                              const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n\n                              return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                          })\n                          .then((nativeContextOrBackupOfflineAudioContext) => {\n                              if (nativeAudioWorkletNodeConstructor === null) {\n                                  throw new SyntaxError();\n                              }\n\n                              try {\n                                  // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                                  new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                              } catch {\n                                  throw new SyntaxError();\n                              }\n                          })\n                          .finally(() => URL.revokeObjectURL(url));\n                  });\n\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        } else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n\n        promise\n            .then(() => {\n                const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n\n                if (updatedResolvedRequestsOfContext === undefined) {\n                    resolvedRequests.set(context, new Set([moduleURL]));\n                } else {\n                    updatedResolvedRequestsOfContext.add(moduleURL);\n                }\n            })\n            .finally(() => {\n                const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n\n                if (updatedOngoingRequestsOfContext !== undefined) {\n                    updatedOngoingRequestsOfContext.delete(moduleURL);\n                }\n            });\n\n        return promise;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}