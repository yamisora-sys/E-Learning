{"ast":null,"code":"export const createDecodeWebMChunk = (readElementContent, readElementType) => {\n  return (dataView, elementType, channelCount) => {\n    const contents = [];\n    let currentElementType = elementType;\n    let offset = 0;\n\n    while (offset < dataView.byteLength) {\n      if (currentElementType === null) {\n        const lengthAndType = readElementType(dataView, offset);\n\n        if (lengthAndType === null) {\n          break;\n        }\n\n        const {\n          length,\n          type\n        } = lengthAndType;\n        currentElementType = type;\n        offset += length;\n      } else {\n        const contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);\n\n        if (contentAndLength === null) {\n          break;\n        }\n\n        const {\n          content,\n          length\n        } = contentAndLength;\n        currentElementType = null;\n        offset += length;\n\n        if (content !== null) {\n          contents.push(content);\n        }\n      }\n    }\n\n    return {\n      contents,\n      currentElementType,\n      offset\n    };\n  };\n};","map":{"version":3,"mappings":"AAEA,OAAO,MAAMA,qBAAqB,GAA4B,CAACC,kBAAD,EAAqBC,eAArB,KAAwC;EAClG,OAAO,CAACC,QAAD,EAAWC,WAAX,EAAwBC,YAAxB,KAAwC;IAC3C,MAAMC,QAAQ,GAAgC,EAA9C;IAEA,IAAIC,kBAAkB,GAAGH,WAAzB;IACA,IAAII,MAAM,GAAG,CAAb;;IAEA,OAAOA,MAAM,GAAGL,QAAQ,CAACM,UAAzB,EAAqC;MACjC,IAAIF,kBAAkB,KAAK,IAA3B,EAAiC;QAC7B,MAAMG,aAAa,GAAGR,eAAe,CAACC,QAAD,EAAWK,MAAX,CAArC;;QAEA,IAAIE,aAAa,KAAK,IAAtB,EAA4B;UACxB;QACH;;QAED,MAAM;UAAEC,MAAF;UAAUC;QAAV,IAAmBF,aAAzB;QAEAH,kBAAkB,GAAGK,IAArB;QACAJ,MAAM,IAAIG,MAAV;MACH,CAXD,MAWO;QACH,MAAME,gBAAgB,GAAGZ,kBAAkB,CAACE,QAAD,EAAWK,MAAX,EAAmBD,kBAAnB,EAAuCF,YAAvC,CAA3C;;QAEA,IAAIQ,gBAAgB,KAAK,IAAzB,EAA+B;UAC3B;QACH;;QAED,MAAM;UAAEC,OAAF;UAAWH;QAAX,IAAsBE,gBAA5B;QAEAN,kBAAkB,GAAG,IAArB;QACAC,MAAM,IAAIG,MAAV;;QAEA,IAAIG,OAAO,KAAK,IAAhB,EAAsB;UAClBR,QAAQ,CAACS,IAAT,CAAcD,OAAd;QACH;MACJ;IACJ;;IAED,OAAO;MAAER,QAAF;MAAYC,kBAAZ;MAAgCC;IAAhC,CAAP;EACH,CArCD;AAsCH,CAvCM","names":["createDecodeWebMChunk","readElementContent","readElementType","dataView","elementType","channelCount","contents","currentElementType","offset","byteLength","lengthAndType","length","type","contentAndLength","content","push"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\extendable-media-recorder\\src\\factories\\decode-web-m-chunk.ts"],"sourcesContent":["import { TDecodeWebMChunkFactory } from '../types';\n\nexport const createDecodeWebMChunk: TDecodeWebMChunkFactory = (readElementContent, readElementType) => {\n    return (dataView, elementType, channelCount) => {\n        const contents: (readonly Float32Array[])[] = [];\n\n        let currentElementType = elementType;\n        let offset = 0;\n\n        while (offset < dataView.byteLength) {\n            if (currentElementType === null) {\n                const lengthAndType = readElementType(dataView, offset);\n\n                if (lengthAndType === null) {\n                    break;\n                }\n\n                const { length, type } = lengthAndType;\n\n                currentElementType = type;\n                offset += length;\n            } else {\n                const contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);\n\n                if (contentAndLength === null) {\n                    break;\n                }\n\n                const { content, length } = contentAndLength;\n\n                currentElementType = null;\n                offset += length;\n\n                if (content !== null) {\n                    contents.push(content);\n                }\n            }\n        }\n\n        return { contents, currentElementType, offset };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}