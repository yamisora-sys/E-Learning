{"ast":null,"code":"export const createRecorderAudioWorkletNodeFactory = (createListener, createPostMessage, on, validateState) => {\n  return function (audioWorkletNodeConstructor, context) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', { ...options,\n      channelCountMode: 'explicit',\n      numberOfInputs: 1,\n      numberOfOutputs: 0\n    });\n    const ongoingRequests = new Map();\n    const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n    const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n    audioWorkletNode.port.start();\n    let state = 'inactive';\n    Object.defineProperties(audioWorkletNode, {\n      pause: {\n        get() {\n          return async () => {\n            validateState(['recording'], state);\n            state = 'paused';\n            return postMessage({\n              method: 'pause'\n            });\n          };\n        }\n\n      },\n      port: {\n        get() {\n          throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n        }\n\n      },\n      record: {\n        get() {\n          return async encoderPort => {\n            validateState(['inactive'], state);\n            state = 'recording';\n            return postMessage({\n              method: 'record',\n              params: {\n                encoderPort\n              }\n            }, [encoderPort]);\n          };\n        }\n\n      },\n      resume: {\n        get() {\n          return async () => {\n            validateState(['paused'], state);\n            state = 'recording';\n            return postMessage({\n              method: 'resume'\n            });\n          };\n        }\n\n      },\n      stop: {\n        get() {\n          return async () => {\n            validateState(['paused', 'recording'], state);\n            state = 'stopped';\n\n            try {\n              await postMessage({\n                method: 'stop'\n              });\n            } finally {\n              unsubscribe();\n            }\n          };\n        }\n\n      }\n    });\n    return audioWorkletNode;\n  };\n};","map":{"version":3,"mappings":"AAeA,OAAO,MAAMA,qCAAqC,GAAG,CACjDC,cADiD,EAEjDC,iBAFiD,EAGjDC,EAHiD,EAIjDC,aAJiD,KAKjD;EACA,OAAO,UACHC,2BADG,EAEHC,OAFG,EAIkF;IAAA,IADrFC,OACqF,uEAD1B,EAC0B;IAIrF,MAAMC,gBAAgB,GAAyB,IAAUH,2BAAV,CAAuCC,OAAvC,EAAgD,kCAAhD,EAAoF,EAC/H,GAAGC,OAD4H;MAE/HE,gBAAgB,EAAE,UAF6G;MAG/HC,cAAc,EAAE,CAH+G;MAI/HC,eAAe,EAAE;IAJ8G,CAApF,CAA/C;IAMA,MAAMC,eAAe,GAAyD,IAAIC,GAAJ,EAA9E;IACA,MAAMC,WAAW,GAAGZ,iBAAiB,CAACU,eAAD,EAAkBJ,gBAAgB,CAACO,IAAnC,CAArC;IACA,MAAMC,WAAW,GAAGb,EAAE,CAACK,gBAAgB,CAACO,IAAlB,EAAwB,SAAxB,CAAF,CAAqCd,cAAc,CAACW,eAAD,CAAnD,CAApB;IAEAJ,gBAAgB,CAACO,IAAjB,CAAsBE,KAAtB;IAEA,IAAIC,KAAK,GAAW,UAApB;IAEAC,MAAM,CAACC,gBAAP,CAAwBZ,gBAAxB,EAA0C;MACtCa,KAAK,EAAE;QACHC,GAAG;UACC,OAAO,YAAW;YACdlB,aAAa,CAAC,CAAC,WAAD,CAAD,EAAgBc,KAAhB,CAAb;YAEAA,KAAK,GAAG,QAAR;YAEA,OAAOJ,WAAW,CAAC;cACfS,MAAM,EAAE;YADO,CAAD,CAAlB;UAGH,CARD;QASH;;MAXE,CAD+B;MActCR,IAAI,EAAE;QACFO,GAAG;UACC,MAAM,IAAIE,KAAJ,CAAU,2DAAV,CAAN;QACH;;MAHC,CAdgC;MAmBtCC,MAAM,EAAE;QACJH,GAAG;UACC,OAAO,MAAOI,WAAP,IAAmC;YACtCtB,aAAa,CAAC,CAAC,UAAD,CAAD,EAAec,KAAf,CAAb;YAEAA,KAAK,GAAG,WAAR;YAEA,OAAOJ,WAAW,CACd;cACIS,MAAM,EAAE,QADZ;cAEII,MAAM,EAAE;gBAAED;cAAF;YAFZ,CADc,EAKd,CAACA,WAAD,CALc,CAAlB;UAOH,CAZD;QAaH;;MAfG,CAnB8B;MAoCtCE,MAAM,EAAE;QACJN,GAAG;UACC,OAAO,YAAW;YACdlB,aAAa,CAAC,CAAC,QAAD,CAAD,EAAac,KAAb,CAAb;YAEAA,KAAK,GAAG,WAAR;YAEA,OAAOJ,WAAW,CAAC;cACfS,MAAM,EAAE;YADO,CAAD,CAAlB;UAGH,CARD;QASH;;MAXG,CApC8B;MAiDtCM,IAAI,EAAE;QACFP,GAAG;UACC,OAAO,YAAW;YACdlB,aAAa,CAAC,CAAC,QAAD,EAAW,WAAX,CAAD,EAA0Bc,KAA1B,CAAb;YAEAA,KAAK,GAAG,SAAR;;YAEA,IAAI;cACA,MAAMJ,WAAW,CAAC;gBAAES,MAAM,EAAE;cAAV,CAAD,CAAjB;YACH,CAFD,SAEU;cACNP,WAAW;YACd;UACJ,CAVD;QAWH;;MAbC;IAjDgC,CAA1C;IAkEA,OAAqCR,gBAArC;EACH,CAzFD;AA0FH,CAhGM","names":["createRecorderAudioWorkletNodeFactory","createListener","createPostMessage","on","validateState","audioWorkletNodeConstructor","context","options","audioWorkletNode","channelCountMode","numberOfInputs","numberOfOutputs","ongoingRequests","Map","postMessage","port","unsubscribe","start","state","Object","defineProperties","pause","get","method","Error","record","encoderPort","params","resume","stop"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\recorder-audio-worklet\\src\\factories\\recorder-audio-worklet-node-factory.ts"],"sourcesContent":["import type {\n    IAudioWorkletNode,\n    TAudioWorkletNodeConstructor,\n    TContext,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeConstructor,\n    TNativeContext\n} from 'standardized-audio-context';\nimport type { on as onFunction } from 'subscribable-things';\nimport type { validateState as validateStateFunction } from '../functions/validate-state';\nimport { INativeRecorderAudioWorkletNode, IRecorderAudioWorkletNode } from '../interfaces';\nimport { TAnyRecorderAudioWorkletNodeOptions, TState } from '../types';\nimport type { createListener as createListenerFunction } from './listener';\nimport type { createPostMessageFactory } from './post-message-factory';\n\nexport const createRecorderAudioWorkletNodeFactory = (\n    createListener: typeof createListenerFunction,\n    createPostMessage: ReturnType<typeof createPostMessageFactory>,\n    on: typeof onFunction,\n    validateState: typeof validateStateFunction\n) => {\n    return <T extends TContext | TNativeContext>(\n        audioWorkletNodeConstructor: T extends TContext ? TAudioWorkletNodeConstructor : TNativeAudioWorkletNodeConstructor,\n        context: T,\n        options: Partial<TAnyRecorderAudioWorkletNodeOptions<T>> = {}\n    ): T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode => {\n        type TAnyAudioWorkletNode = T extends TContext ? IAudioWorkletNode<T> : TNativeAudioWorkletNode;\n        type TAnyRecorderAudioWorkletNode = T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode;\n\n        const audioWorkletNode: TAnyAudioWorkletNode = new (<any>audioWorkletNodeConstructor)(context, 'recorder-audio-worklet-processor', {\n            ...options,\n            channelCountMode: 'explicit',\n            numberOfInputs: 1,\n            numberOfOutputs: 0\n        });\n        const ongoingRequests: Map<number, { reject: Function; resolve: Function }> = new Map();\n        const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n        const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n\n        audioWorkletNode.port.start();\n\n        let state: TState = 'inactive';\n\n        Object.defineProperties(audioWorkletNode, {\n            pause: {\n                get(): TAnyRecorderAudioWorkletNode['pause'] {\n                    return async () => {\n                        validateState(['recording'], state);\n\n                        state = 'paused';\n\n                        return postMessage({\n                            method: 'pause'\n                        });\n                    };\n                }\n            },\n            port: {\n                get(): TAnyRecorderAudioWorkletNode['port'] {\n                    throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n                }\n            },\n            record: {\n                get(): TAnyRecorderAudioWorkletNode['record'] {\n                    return async (encoderPort: MessagePort) => {\n                        validateState(['inactive'], state);\n\n                        state = 'recording';\n\n                        return postMessage(\n                            {\n                                method: 'record',\n                                params: { encoderPort }\n                            },\n                            [encoderPort]\n                        );\n                    };\n                }\n            },\n            resume: {\n                get(): TAnyRecorderAudioWorkletNode['resume'] {\n                    return async () => {\n                        validateState(['paused'], state);\n\n                        state = 'recording';\n\n                        return postMessage({\n                            method: 'resume'\n                        });\n                    };\n                }\n            },\n            stop: {\n                get(): TAnyRecorderAudioWorkletNode['stop'] {\n                    return async () => {\n                        validateState(['paused', 'recording'], state);\n\n                        state = 'stopped';\n\n                        try {\n                            await postMessage({ method: 'stop' });\n                        } finally {\n                            unsubscribe();\n                        }\n                    };\n                }\n            }\n        });\n\n        return <TAnyRecorderAudioWorkletNode>audioWorkletNode;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}