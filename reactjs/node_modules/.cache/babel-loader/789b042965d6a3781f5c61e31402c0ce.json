{"ast":null,"code":"import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  let nativeOfflineAudioContext = null;\n  return class AudioBuffer {\n    constructor(options) {\n      if (nativeOfflineAudioContextConstructor === null) {\n        throw new Error('Missing the native OfflineAudioContext constructor.');\n      }\n\n      const {\n        length,\n        numberOfChannels,\n        sampleRate\n      } = { ...DEFAULT_OPTIONS,\n        ...options\n      };\n\n      if (nativeOfflineAudioContext === null) {\n        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n      }\n      /*\n       * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n       * factory function. But since Firefox also supports the constructor everything should be fine.\n       */\n\n\n      const audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({\n        length,\n        numberOfChannels,\n        sampleRate\n      }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate); // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n\n      if (audioBuffer.numberOfChannels === 0) {\n        throw createNotSupportedError();\n      } // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n      // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n\n\n      if (typeof audioBuffer.copyFromChannel !== 'function') {\n        wrapAudioBufferCopyChannelMethods(audioBuffer);\n        wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n      } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n        wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n      }\n\n      audioBufferStore.add(audioBuffer);\n      /*\n       * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n       * (Offline)AudioContexts.\n       */\n\n      return audioBuffer;\n    }\n\n    static [Symbol.hasInstance](instance) {\n      return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);\n    }\n\n  };\n};","map":{"version":3,"mappings":"AAAA,SAASA,mDAAT,QAAoE,yEAApE;AACA,SAASC,mCAAT,QAAoD,sDAApD;AAIA,MAAMC,eAAe,GAAG;EACpBC,gBAAgB,EAAE;AADE,CAAxB;AAIA,OAAO,MAAMC,4BAA4B,GAAmC,CACxEC,gBADwE,EAExEC,eAFwE,EAGxEC,uBAHwE,EAIxEC,4BAJwE,EAKxEC,oCALwE,EAMxEC,uCANwE,EAOxEC,iCAPwE,EAQxEC,4CARwE,KASxE;EACA,IAAIC,yBAAyB,GAAsC,IAAnE;EAEA,OAAO,MAAMC,WAAN,CAAiB;IAsBpBC,YAAYC,OAAZ,EAAwC;MACpC,IAAIP,oCAAoC,KAAK,IAA7C,EAAmD;QAC/C,MAAM,IAAIQ,KAAJ,CAAU,qDAAV,CAAN;MACH;;MAED,MAAM;QAAEC,MAAF;QAAUf,gBAAV;QAA4BgB;MAA5B,IAA2C,EAAE,GAAGjB,eAAL;QAAsB,GAAGc;MAAzB,CAAjD;;MAEA,IAAIH,yBAAyB,KAAK,IAAlC,EAAwC;QACpCA,yBAAyB,GAAG,IAAIJ,oCAAJ,CAAyC,CAAzC,EAA4C,CAA5C,EAA+C,KAA/C,CAA5B;MACH;MAED;;;;;;MAIA,MAAMW,WAAW,GACbZ,4BAA4B,KAAK,IAAjC,IACAF,eAAe,CAACI,uCAAD,EAA0CA,uCAA1C,CADf,GAEM,IAAIF,4BAAJ,CAAiC;QAAEU,MAAF;QAAUf,gBAAV;QAA4BgB;MAA5B,CAAjC,CAFN,GAGMN,yBAAyB,CAACQ,YAA1B,CAAuClB,gBAAvC,EAAyDe,MAAzD,EAAiEC,UAAjE,CAJV,CAfoC,CAqBpC;;MACA,IAAIC,WAAW,CAACjB,gBAAZ,KAAiC,CAArC,EAAwC;QACpC,MAAMI,uBAAuB,EAA7B;MACH,CAxBmC,CA0BpC;MACA;;;MACA,IAAI,OAAOa,WAAW,CAACE,eAAnB,KAAuC,UAA3C,EAAuD;QACnDX,iCAAiC,CAACS,WAAD,CAAjC;QACAnB,mCAAmC,CAACmB,WAAD,CAAnC,CAFmD,CAGnD;MACH,CAJD,MAIO,IACH,CAACd,eAAe,CAACN,mDAAD,EAAsD,MAClEA,mDAAmD,CAACoB,WAAD,CADvC,CADb,EAIL;QACER,4CAA4C,CAACQ,WAAD,CAA5C;MACH;;MAEDf,gBAAgB,CAACkB,GAAjB,CAAqBH,WAArB;MAEA;;;;;MAIA,OAAOA,WAAP;IACH;;IAEgC,QAAlBI,MAAM,CAACC,WAAW,EAAEC,QAAF,EAAmB;MAChD,OACKA,QAAQ,KAAK,IAAb,IAAqB,OAAOA,QAAP,KAAoB,QAAzC,IAAqDC,MAAM,CAACC,cAAP,CAAsBF,QAAtB,MAAoCZ,WAAW,CAACe,SAAtG,IACAxB,gBAAgB,CAACyB,GAAjB,CAA0BJ,QAA1B,CAFJ;IAIH;;EA5EmB,CAAxB;AA8EH,CA1FM","names":["testAudioBufferCopyChannelMethodsOutOfBoundsSupport","wrapAudioBufferGetChannelDataMethod","DEFAULT_OPTIONS","numberOfChannels","createAudioBufferConstructor","audioBufferStore","cacheTestResult","createNotSupportedError","nativeAudioBufferConstructor","nativeOfflineAudioContextConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","nativeOfflineAudioContext","AudioBuffer","constructor","options","Error","length","sampleRate","audioBuffer","createBuffer","copyFromChannel","add","Symbol","hasInstance","instance","Object","getPrototypeOf","prototype","has"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\audio-buffer-constructor.ts"],"sourcesContent":["import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { IAudioBuffer, IAudioBufferOptions } from '../interfaces';\nimport { TAudioBufferConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createAudioBufferConstructor: TAudioBufferConstructorFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    testNativeAudioBufferConstructorSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    let nativeOfflineAudioContext: null | TNativeOfflineAudioContext = null;\n\n    return class AudioBuffer implements IAudioBuffer {\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyFromChannel!: (destination: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyToChannel!: (source: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public duration!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public getChannelData!: (channel: number) => Float32Array;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public length!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public numberOfChannels!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public sampleRate!: number;\n\n        constructor(options: IAudioBufferOptions) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer =\n                nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                    ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                    : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            } else if (\n                !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                    testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                )\n            ) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n\n            audioBufferStore.add(audioBuffer);\n\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(<any>instance)\n            );\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}