{"ast":null,"code":"import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n  return (nativeContext, _ref) => {\n    let {\n      offset,\n      ...audioNodeOptions\n    } = _ref;\n    const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n    const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n      buffer: null,\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      playbackRate: 1\n    });\n    const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions,\n      gain: offset\n    }); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n\n    const channelData = audioBuffer.getChannelData(0); // Bug #95: Safari does not play or loop one sample buffers.\n\n    channelData[0] = 1;\n    channelData[1] = 1;\n    audioBufferSourceNode.buffer = audioBuffer;\n    audioBufferSourceNode.loop = true;\n    const nativeConstantSourceNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return gainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        gainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return gainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        gainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return gainNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        gainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return gainNode.context;\n      },\n\n      get inputs() {\n        return [];\n      },\n\n      get numberOfInputs() {\n        return audioBufferSourceNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return gainNode.numberOfOutputs;\n      },\n\n      get offset() {\n        return gainNode.gain;\n      },\n\n      get onended() {\n        return audioBufferSourceNode.onended;\n      },\n\n      set onended(value) {\n        audioBufferSourceNode.onended = value;\n      },\n\n      addEventListener() {\n        return audioBufferSourceNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n\n      dispatchEvent() {\n        return audioBufferSourceNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n\n      removeEventListener() {\n        return audioBufferSourceNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n\n      start() {\n        let when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n      },\n\n      stop() {\n        let when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n      }\n\n    };\n\n    const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n\n    const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode); // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, audioBufferSourceNode);\n    return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"mappings":"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","names":["interceptConnections","createNativeConstantSourceNodeFakerFactory","addSilentConnection","createNativeAudioBufferSourceNode","createNativeGainNode","monitorConnections","nativeContext","offset","audioNodeOptions","audioBuffer","createBuffer","audioBufferSourceNode","buffer","channelCount","channelCountMode","channelInterpretation","loop","loopEnd","loopStart","playbackRate","gainNode","gain","channelData","getChannelData","nativeConstantSourceNodeFaker","bufferSize","undefined","value","context","inputs","numberOfInputs","numberOfOutputs","onended","addEventListener","dispatchEvent","removeEventListener","start","when","call","stop","whenConnected","connect","whenDisconnected","disconnect"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\native-constant-source-node-faker-factory.ts"],"sourcesContent":["import { interceptConnections } from '../helpers/intercept-connections';\nimport {\n    TNativeAudioBufferSourceNode,\n    TNativeAudioNode,\n    TNativeConstantSourceNode,\n    TNativeConstantSourceNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeConstantSourceNodeFakerFactory: TNativeConstantSourceNodeFakerFactoryFactory = (\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeConstantSourceNode['channelCountMode'] {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeConstantSourceNode['channelInterpretation'] {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context(): TNativeConstantSourceNode['context'] {\n                return gainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [];\n            },\n            get numberOfInputs(): number {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return gainNode.numberOfOutputs;\n            },\n            get offset(): TNativeConstantSourceNode['offset'] {\n                return gainNode.gain;\n            },\n            get onended(): TNativeConstantSourceNode['onended'] {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = <TNativeAudioBufferSourceNode['onended']>value;\n            },\n            addEventListener(...args: any[]): void {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0): void {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0): void {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n"]},"metadata":{},"sourceType":"module"}