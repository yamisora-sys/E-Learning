{"ast":null,"code":"import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode) => {\n  return () => {\n    const renderedNativeWaveShaperNodes = new WeakMap();\n\n    const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {\n      let nativeWaveShaperNode = getNativeAudioNode(proxy); // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n\n      const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n      if (!nativeWaveShaperNodeIsOwnedByContext) {\n        const options = {\n          channelCount: nativeWaveShaperNode.channelCount,\n          channelCountMode: nativeWaveShaperNode.channelCountMode,\n          channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n          curve: nativeWaveShaperNode.curve,\n          oversample: nativeWaveShaperNode.oversample\n        };\n        nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n      }\n\n      renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n      if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n      } else {\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n      }\n\n      return nativeWaveShaperNode;\n    };\n\n    return {\n      render(proxy, nativeOfflineAudioContext) {\n        const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeWaveShaperNode !== undefined) {\n          return Promise.resolve(renderedNativeWaveShaperNode);\n        }\n\n        return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n      }\n\n    };\n  };\n};","map":{"version":3,"mappings":"AAAA,SAASA,sBAAT,QAAuC,mCAAvC;AACA,SAASC,gBAAT,QAAiC,gCAAjC;AAIA,OAAO,MAAMC,mCAAmC,GAA0C,CACtFC,0BADsF,EAEtFC,kBAFsF,EAGtFC,uBAHsF,KAItF;EACA,OAAO,MAAmE;IACtE,MAAMC,6BAA6B,GAAG,IAAIC,OAAJ,EAAtC;;IAEA,MAAMC,oBAAoB,GAAG,OAAOC,KAAP,EAAkCC,yBAAlC,KAA2F;MACpH,IAAIC,oBAAoB,GAAGP,kBAAkB,CAA2BK,KAA3B,CAA7C,CADoH,CAGpH;;MACA,MAAMG,oCAAoC,GAAGX,gBAAgB,CAACU,oBAAD,EAAuBD,yBAAvB,CAA7D;;MAEA,IAAI,CAACE,oCAAL,EAA2C;QACvC,MAAMC,OAAO,GAAG;UACZC,YAAY,EAAEH,oBAAoB,CAACG,YADvB;UAEZC,gBAAgB,EAAEJ,oBAAoB,CAACI,gBAF3B;UAGZC,qBAAqB,EAAEL,oBAAoB,CAACK,qBAHhC;UAIZC,KAAK,EAAEN,oBAAoB,CAACM,KAJhB;UAKZC,UAAU,EAAEP,oBAAoB,CAACO;QALrB,CAAhB;QAQAP,oBAAoB,GAAGR,0BAA0B,CAACO,yBAAD,EAA4BG,OAA5B,CAAjD;MACH;;MAEDP,6BAA6B,CAACa,GAA9B,CAAkCT,yBAAlC,EAA6DC,oBAA7D;;MAEA,IAAIX,sBAAsB,CAACW,oBAAD,CAA1B,EAAkD;QAC9C,MAAMN,uBAAuB,CAACI,KAAD,EAAQC,yBAAR,EAAmCC,oBAAoB,CAACS,MAArB,CAA4B,CAA5B,CAAnC,CAA7B;MACH,CAFD,MAEO;QACH,MAAMf,uBAAuB,CAACI,KAAD,EAAQC,yBAAR,EAAmCC,oBAAnC,CAA7B;MACH;;MAED,OAAOA,oBAAP;IACH,CA3BD;;IA6BA,OAAO;MACHU,MAAM,CAACZ,KAAD,EAA4BC,yBAA5B,EAAiF;QACnF,MAAMY,4BAA4B,GAAGhB,6BAA6B,CAACiB,GAA9B,CAAkCb,yBAAlC,CAArC;;QAEA,IAAIY,4BAA4B,KAAKE,SAArC,EAAgD;UAC5C,OAAOC,OAAO,CAACC,OAAR,CAAgBJ,4BAAhB,CAAP;QACH;;QAED,OAAOd,oBAAoB,CAACC,KAAD,EAAQC,yBAAR,CAA3B;MACH;;IATE,CAAP;EAWH,CA3CD;AA4CH,CAjDM","names":["isNativeAudioNodeFaker","isOwnedByContext","createWaveShaperNodeRendererFactory","createNativeWaveShaperNode","getNativeAudioNode","renderInputsOfAudioNode","renderedNativeWaveShaperNodes","WeakMap","createWaveShaperNode","proxy","nativeOfflineAudioContext","nativeWaveShaperNode","nativeWaveShaperNodeIsOwnedByContext","options","channelCount","channelCountMode","channelInterpretation","curve","oversample","set","inputs","render","renderedNativeWaveShaperNode","get","undefined","Promise","resolve"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\standardized-audio-context\\src\\factories\\wave-shaper-node-renderer-factory.ts"],"sourcesContent":["import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IWaveShaperNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeWaveShaperNode, TWaveShaperNodeRendererFactoryFactory } from '../types';\n\nexport const createWaveShaperNodeRendererFactory: TWaveShaperNodeRendererFactoryFactory = (\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeWaveShaperNodes = new WeakMap<TNativeOfflineAudioContext, TNativeWaveShaperNode>();\n\n        const createWaveShaperNode = async (proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode<T, TNativeWaveShaperNode>(proxy);\n\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n\n            return nativeWaveShaperNode;\n        };\n\n        return {\n            render(proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeWaveShaperNode> {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}