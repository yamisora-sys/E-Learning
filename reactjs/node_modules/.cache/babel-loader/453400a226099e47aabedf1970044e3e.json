{"ast":null,"code":"export const createMediaRecorderConstructor = (createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, eventTargetConstructor, nativeMediaRecorderConstructor) => {\n  return class MediaRecorder extends eventTargetConstructor {\n    constructor(stream) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        mimeType\n      } = options;\n\n      if (nativeMediaRecorderConstructor !== null && ( // Bug #10: Safari does not yet implement the isTypeSupported() method.\n      mimeType === undefined || nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType))) {\n        const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n        super(internalMediaRecorder);\n        this._internalMediaRecorder = internalMediaRecorder;\n      } else if (mimeType !== undefined && encoderRegexes.some(regex => regex.test(mimeType))) {\n        super(); // Bug #10: Safari does not yet implement the isTypeSupported() method.\n\n        if (nativeMediaRecorderConstructor !== null && nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')) {\n          this._internalMediaRecorder = createWebmPcmMediaRecorder(this, nativeMediaRecorderConstructor, stream, mimeType);\n        } else {\n          this._internalMediaRecorder = createWebAudioMediaRecorder(this, stream, mimeType);\n        }\n      } else {\n        // This is creating a native MediaRecorder just to provoke it to throw an error.\n        if (nativeMediaRecorderConstructor !== null) {\n          createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n        }\n\n        throw createNotSupportedError();\n      }\n\n      this._ondataavailable = null;\n      this._onerror = null;\n      this._onpause = null;\n      this._onresume = null;\n      this._onstart = null;\n      this._onstop = null;\n    }\n\n    get mimeType() {\n      return this._internalMediaRecorder.mimeType;\n    }\n\n    get ondataavailable() {\n      return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n    }\n\n    set ondataavailable(value) {\n      if (this._ondataavailable !== null) {\n        this.removeEventListener('dataavailable', this._ondataavailable[1]);\n      }\n\n      if (typeof value === 'function') {\n        const boundListener = value.bind(this);\n        this.addEventListener('dataavailable', boundListener);\n        this._ondataavailable = [value, boundListener];\n      } else {\n        this._ondataavailable = null;\n      }\n    }\n\n    get onerror() {\n      return this._onerror === null ? this._onerror : this._onerror[0];\n    }\n\n    set onerror(value) {\n      if (this._onerror !== null) {\n        this.removeEventListener('error', this._onerror[1]);\n      }\n\n      if (typeof value === 'function') {\n        const boundListener = value.bind(this);\n        this.addEventListener('error', boundListener);\n        this._onerror = [value, boundListener];\n      } else {\n        this._onerror = null;\n      }\n    }\n\n    get onpause() {\n      return this._onpause === null ? this._onpause : this._onpause[0];\n    }\n\n    set onpause(value) {\n      if (this._onpause !== null) {\n        this.removeEventListener('pause', this._onpause[1]);\n      }\n\n      if (typeof value === 'function') {\n        const boundListener = value.bind(this);\n        this.addEventListener('pause', boundListener);\n        this._onpause = [value, boundListener];\n      } else {\n        this._onpause = null;\n      }\n    }\n\n    get onresume() {\n      return this._onresume === null ? this._onresume : this._onresume[0];\n    }\n\n    set onresume(value) {\n      if (this._onresume !== null) {\n        this.removeEventListener('resume', this._onresume[1]);\n      }\n\n      if (typeof value === 'function') {\n        const boundListener = value.bind(this);\n        this.addEventListener('resume', boundListener);\n        this._onresume = [value, boundListener];\n      } else {\n        this._onresume = null;\n      }\n    }\n\n    get onstart() {\n      return this._onstart === null ? this._onstart : this._onstart[0];\n    }\n\n    set onstart(value) {\n      if (this._onstart !== null) {\n        this.removeEventListener('start', this._onstart[1]);\n      }\n\n      if (typeof value === 'function') {\n        const boundListener = value.bind(this);\n        this.addEventListener('start', boundListener);\n        this._onstart = [value, boundListener];\n      } else {\n        this._onstart = null;\n      }\n    }\n\n    get onstop() {\n      return this._onstop === null ? this._onstop : this._onstop[0];\n    }\n\n    set onstop(value) {\n      if (this._onstop !== null) {\n        this.removeEventListener('stop', this._onstop[1]);\n      }\n\n      if (typeof value === 'function') {\n        const boundListener = value.bind(this);\n        this.addEventListener('stop', boundListener);\n        this._onstop = [value, boundListener];\n      } else {\n        this._onstop = null;\n      }\n    }\n\n    get state() {\n      return this._internalMediaRecorder.state;\n    }\n\n    pause() {\n      return this._internalMediaRecorder.pause();\n    }\n\n    resume() {\n      return this._internalMediaRecorder.resume();\n    }\n\n    start(timeslice) {\n      return this._internalMediaRecorder.start(timeslice);\n    }\n\n    stop() {\n      return this._internalMediaRecorder.stop();\n    }\n\n    static isTypeSupported(mimeType) {\n      return nativeMediaRecorderConstructor !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.\n      nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType) || encoderRegexes.some(regex => regex.test(mimeType));\n    }\n\n  };\n};","map":{"version":3,"mappings":"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","names":["createMediaRecorderConstructor","createNativeMediaRecorder","createNotSupportedError","createWebAudioMediaRecorder","createWebmPcmMediaRecorder","encoderRegexes","eventTargetConstructor","nativeMediaRecorderConstructor","MediaRecorder","constructor","stream","options","mimeType","undefined","isTypeSupported","internalMediaRecorder","_internalMediaRecorder","some","regex","test","_ondataavailable","_onerror","_onpause","_onresume","_onstart","_onstop","ondataavailable","value","removeEventListener","boundListener","bind","addEventListener","onerror","onpause","onresume","onstart","onstop","state","pause","resume","start","timeslice","stop"],"sources":["D:\\programer\\xampp\\htdocs\\E-Learning\\reactjs\\node_modules\\extendable-media-recorder\\src\\factories\\media-recorder-constructor.ts"],"sourcesContent":["import { IMediaRecorder, IMediaRecorderEventMap, IMediaRecorderOptions } from '../interfaces';\nimport {\n    TBlobEventHandler,\n    TErrorEventHandler,\n    TEventHandler,\n    TMediaRecorderConstructorFactory,\n    TNativeEventTarget,\n    TRecordingState\n} from '../types';\n\nexport const createMediaRecorderConstructor: TMediaRecorderConstructorFactory = (\n    createNativeMediaRecorder,\n    createNotSupportedError,\n    createWebAudioMediaRecorder,\n    createWebmPcmMediaRecorder,\n    encoderRegexes,\n    eventTargetConstructor,\n    nativeMediaRecorderConstructor\n) => {\n    return class MediaRecorder extends eventTargetConstructor<IMediaRecorderEventMap> implements IMediaRecorder {\n        private _internalMediaRecorder: Omit<\n            IMediaRecorder,\n            'ondataavailable' | 'onerror' | 'onpause' | 'onresume' | 'onstart' | 'onstop' | keyof TNativeEventTarget\n        >;\n\n        private _ondataavailable: null | [TBlobEventHandler<this>, TBlobEventHandler<this>];\n\n        private _onerror: null | [TErrorEventHandler<this>, TErrorEventHandler<this>];\n\n        private _onpause: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onresume: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onstart: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onstop: null | [TEventHandler<this>, TEventHandler<this>];\n\n        constructor(stream: MediaStream, options: IMediaRecorderOptions = {}) {\n            const { mimeType } = options;\n\n            if (\n                nativeMediaRecorderConstructor !== null &&\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                (mimeType === undefined ||\n                    (nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                        nativeMediaRecorderConstructor.isTypeSupported(mimeType)))\n            ) {\n                const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n\n                super(internalMediaRecorder);\n\n                this._internalMediaRecorder = internalMediaRecorder;\n            } else if (mimeType !== undefined && encoderRegexes.some((regex) => regex.test(mimeType))) {\n                super();\n\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                if (\n                    nativeMediaRecorderConstructor !== null &&\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')\n                ) {\n                    this._internalMediaRecorder = createWebmPcmMediaRecorder(this, nativeMediaRecorderConstructor, stream, mimeType);\n                } else {\n                    this._internalMediaRecorder = createWebAudioMediaRecorder(this, stream, mimeType);\n                }\n            } else {\n                // This is creating a native MediaRecorder just to provoke it to throw an error.\n                if (nativeMediaRecorderConstructor !== null) {\n                    createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n                }\n\n                throw createNotSupportedError();\n            }\n\n            this._ondataavailable = null;\n            this._onerror = null;\n            this._onpause = null;\n            this._onresume = null;\n            this._onstart = null;\n            this._onstop = null;\n        }\n\n        get mimeType(): string {\n            return this._internalMediaRecorder.mimeType;\n        }\n\n        get ondataavailable(): null | TBlobEventHandler<this> {\n            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n        }\n\n        set ondataavailable(value) {\n            if (this._ondataavailable !== null) {\n                this.removeEventListener('dataavailable', this._ondataavailable[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('dataavailable', boundListener);\n\n                this._ondataavailable = [value, boundListener];\n            } else {\n                this._ondataavailable = null;\n            }\n        }\n\n        get onerror(): null | TErrorEventHandler<this> {\n            return this._onerror === null ? this._onerror : this._onerror[0];\n        }\n\n        set onerror(value) {\n            if (this._onerror !== null) {\n                this.removeEventListener('error', this._onerror[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('error', boundListener);\n\n                this._onerror = [value, boundListener];\n            } else {\n                this._onerror = null;\n            }\n        }\n\n        get onpause(): null | TEventHandler<this> {\n            return this._onpause === null ? this._onpause : this._onpause[0];\n        }\n\n        set onpause(value) {\n            if (this._onpause !== null) {\n                this.removeEventListener('pause', this._onpause[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('pause', boundListener);\n\n                this._onpause = [value, boundListener];\n            } else {\n                this._onpause = null;\n            }\n        }\n\n        get onresume(): null | TEventHandler<this> {\n            return this._onresume === null ? this._onresume : this._onresume[0];\n        }\n\n        set onresume(value) {\n            if (this._onresume !== null) {\n                this.removeEventListener('resume', this._onresume[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('resume', boundListener);\n\n                this._onresume = [value, boundListener];\n            } else {\n                this._onresume = null;\n            }\n        }\n\n        get onstart(): null | TEventHandler<this> {\n            return this._onstart === null ? this._onstart : this._onstart[0];\n        }\n\n        set onstart(value) {\n            if (this._onstart !== null) {\n                this.removeEventListener('start', this._onstart[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('start', boundListener);\n\n                this._onstart = [value, boundListener];\n            } else {\n                this._onstart = null;\n            }\n        }\n\n        get onstop(): null | TEventHandler<this> {\n            return this._onstop === null ? this._onstop : this._onstop[0];\n        }\n\n        set onstop(value) {\n            if (this._onstop !== null) {\n                this.removeEventListener('stop', this._onstop[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('stop', boundListener);\n\n                this._onstop = [value, boundListener];\n            } else {\n                this._onstop = null;\n            }\n        }\n\n        get state(): TRecordingState {\n            return this._internalMediaRecorder.state;\n        }\n\n        public pause(): void {\n            return this._internalMediaRecorder.pause();\n        }\n\n        public resume(): void {\n            return this._internalMediaRecorder.resume();\n        }\n\n        public start(timeslice?: number): void {\n            return this._internalMediaRecorder.start(timeslice);\n        }\n\n        public stop(): void {\n            return this._internalMediaRecorder.stop();\n        }\n\n        public static isTypeSupported(mimeType: string): boolean {\n            return (\n                (nativeMediaRecorderConstructor !== null &&\n                    // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported(mimeType)) ||\n                encoderRegexes.some((regex) => regex.test(mimeType))\n            );\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}